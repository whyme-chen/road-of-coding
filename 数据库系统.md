# 基础理论

## 基本概念

1. 数据库（DB）
   * 定义：**存储、组织和管理数据的仓库**，支持高效的数据操作（增删改查）
   * 特点：持久化存储、共享性、减少冗余、数据独立性。
2. 数据库管理系统（DBMS）：管理数据库的软件（如MySQL、Oracle、SQL Server），提供数据定义、操作、事务管理和安全性控制。
3. 数据库系统（DBS）
4. 数据库管理员（DBA）

## 数据模型

数据模型是**用于定义数据库中数据结构的工具**。它描述了数据的组织方式以及数据之间的关系。常见的数据模型有：

- **关系模型**：数据**以二维表（关系）的形式组织，表由行（记录）和列（字段）组成**。关系模型支持 SQL 查询语言，并且广泛应用于各种数据库系统（如 MySQL、PostgreSQL）。（主流）
- **层次模型**：数据以树形结构进行组织，父子节点之间有明确的层级关系。最早的数据库模型之一，比较适用于处理层级结构的数据。（已较少使用）
- **网络模型**：数据以图的形式组织，记录通过不同的链接形成一个有向图，支持多对多的关系。（复杂，较少使用）
- **对象模型**：数据以对象的形式存储，与面向对象的编程语言相似，适用于对象数据库。
- **非关系模型**
  - **文档模型**：数据存储在文档格式中，通常采用 JSON 或 BSON 等格式，适用于 NoSQL 数据库（如 MongoDB）。
  - **键值型**：（如Redis）
  - **图数据库**：（如Neo4j）

## 关系型数据库设计

### 步骤

1. **需求分析**
   - 明确业务需求，确定数据范围、操作类型和性能要求。
2. **概念设计（E-R模型）**：使用实体-关系（ER）模型或 UML 类图等工具，设计数据库的概念模型，明确数据的结构和关系。
   - **实体（Entity）**：独立存在的对象（如“学生”）。
   - **属性（Attribute）**：实体的特征（如“学号”、“姓名”）。
   - **联系（Relationship）**：实体间的关联（如“学生-选课-课程”）。
   - 绘制E-R图，描述实体、属性和关系。
3. **逻辑设计**
   - 将E-R模型转换为关系模式（表结构），明确主属性、非主属性，定义主键、外键和约束。
4. **物理设计**
   - 选择存储引擎、设计索引、分区策略等，优化存储和性能。
5. **实施与维护**
   - 建表、导入数据、编写SQL语句，并持续监控和优化。

### 范式

数据库范式是为了减少数据库中数据冗余和避免不一致性而提出的一系列规则。常见的范式有：

- **第一范式（1NF）**：要求每个字段都应该是原子性的，即每个字段只能包含一个值。
- **第二范式（2NF）**：要求数据库符合 1NF，并且所有非主键字段完全依赖于主键（即不存在部分依赖）。
- **第三范式（3NF）**：要求数据库符合 2NF，并且没有非主键字段依赖于其他非主键字段（即不存在传递依赖）。
- **BCNF（博茨-科得范式）**：进一步强化了 3NF，要求每个决定因素都是候选键。
- **第四范式（4NF）**：处理多值依赖，要求每个多值依赖都应该被拆分成单独的关系。
- **第五范式（5NF）**：要求数据库没有冗余，并且每个分解的关系都能够被合并为原始关系。

> 反范式化：实际应用中，有时为了查询性能，会适当降低范式要求，比如主动冗余部分相关数据。

### SQL操作

1. **数据定义（DDL）**

   ```
   CREATE TABLE 学生 (学号 INT PRIMARY KEY, 姓名 VARCHAR(20));
   ALTER TABLE 学生 ADD 年龄 INT;
   DROP TABLE 学生;
   ```

2. **数据操作（DML）**

   ```
   INSERT INTO 学生 VALUES (1001, '张三', 20);
   UPDATE 学生 SET 年龄 = 21 WHERE 学号 = 1001;
   DELETE FROM 学生 WHERE 学号 = 1001;
   ```

3. **数据查询（DQL）**

   ```
   SELECT 姓名, 年龄 FROM 学生 WHERE 年龄 > 18 ORDER BY 学号;
   ```

### 关系操作

- **选择（Selection）**：从一个关系中选择满足某一条件的行（记录）。
- **投影（Projection）**：从一个关系中选择特定的列（属性）。
- **连接（Join）**：将两个或多个关系根据某些条件结合起来，形成一个新的关系。常见的连接类型包括内连接（INNER JOIN）、外连接（OUTER JOIN）、交叉连接（CROSS JOIN）等。
- **并集（Union）**：将两个关系中的数据合并成一个关系。
- **差集（Difference）**：返回一个关系中存在而另一个关系中不存在的记录。
- **笛卡尔积（Cartesian Product）**：将两个关系的每一行与另一个关系的每一行进行组合。

### 事务（**ACID** ）

1. **事务（Transaction）**
   - 一组原子性操作的集合（如转账：扣款+入账）。
2. 特性
   * **原子性（Atomicity）**：事务中的所有操作要么全部执行，要么全部不执行，不会出现中间状态。
   * **一致性（Consistency）**：事务执行前后，数据库必须保持一致性，即满足所有的约束条件。
   * **隔离性（Isolation）**：并发执行的事务彼此之间不会互相影响，事务的执行结果不受其他事务的影响。
   * **持久性（Durability）**：事务一旦提交，其结果是永久性的，即使系统崩溃也不会丢失数据。

# MySQL 

学习视频：https://www.bilibili.com/video/BV1Kr4y1i7ru/?spm_id_from=333.999.0.0&vd_source=fabefd3fabfadb9324761989b55c26ea

参考链接：https://blog.csdn.net/fannyoona/article/details/105565198

## 概述

1. 基本概念

   ![image-20220929184318530](https://whymechen.oss-cn-chengdu.aliyuncs.com/image/202209291843086.png)

   * 数据库：保存有组织的数据的容器
   * 表：某种特定类型数据的结构化清单

   * 列：表中的一个字段，所有的表都是由一个或多个列组合而成。
   * 数据类型：每个列都有相应的数据类型来限制该列中存储的数据
   * 行：表中的一个记录。

   * 主键：一列（或一组列），其值可以唯一标识表中每一行。主键应该满足如下条件：

     * 任意两行都不具有相同的主键值
     * 每一行都必须具有一个主键值（主键值列不允许NULL值）
     * 主键列中的值不允许修改或更新
     * 主键值不能重复（如果某行从表中删除，它的主键不能赋给以后的新行）

2. 目前主流的数据库管理系统

3. mysql的安装及启动

   * 版本
   * 安装
   * 启动
   * 连接

4. 数据模型

   * 二维表

## SQL语句

1. 简介：SQL是结构化查询语言（Structured Query Language）的缩写。SQL是一种**专门用来与数据库沟通的语言**。

2. 通用语法

   ![image-20220929185932212](https://whymechen.oss-cn-chengdu.aliyuncs.com/image/202209291859003.png)

3. SQL语句的分类

   ![image-20220929190026906](https://whymechen.oss-cn-chengdu.aliyuncs.com/image/202209291900741.png)

4. mysql数据类型

   * 数值类型

     ![image-20220929192216973](https://whymechen.oss-cn-chengdu.aliyuncs.com/image/202209291922020.png)

   * 字符串类型

     ![image-20220929192405663](https://whymechen.oss-cn-chengdu.aliyuncs.com/image/202209291936879.png) 

   * 日期类型

     ![image-20220929193610041](https://whymechen.oss-cn-chengdu.aliyuncs.com/image/202209291936189.png)

5. 图形化界面客户端

   * sqlyog
   * Navicat
   * DataGrip

### DDL

1. 数据库操作

   ![image-20220929190845682](https://whymechen.oss-cn-chengdu.aliyuncs.com/image/202209291909371.png)

2. 表操作

   ![image-20220929191028497](https://whymechen.oss-cn-chengdu.aliyuncs.com/image/202209291910688.png)

   ![image-20220929191929527](https://whymechen.oss-cn-chengdu.aliyuncs.com/image/202209291919876.png)

   ![image-20220929195033414](https://whymechen.oss-cn-chengdu.aliyuncs.com/image/202209291950632.png)

   ![image-20220929195114357](https://whymechen.oss-cn-chengdu.aliyuncs.com/image/202209291951052.png)

   ![image-20220929195213082](https://whymechen.oss-cn-chengdu.aliyuncs.com/image/202209291952213.png)

   ![image-20220929195324785](https://whymechen.oss-cn-chengdu.aliyuncs.com/image/202209291953147.png)

3. 小结：

   ![image-20220929195550259](https://whymechen.oss-cn-chengdu.aliyuncs.com/image/202209291955107.png)

### DML

1. 添加数据（insert）

   ![image-20220930183201553](https://whymechen.oss-cn-chengdu.aliyuncs.com/image/202209301832066.png)

2. 修改数据（update）

   ![image-20220930184320840](https://whymechen.oss-cn-chengdu.aliyuncs.com/image/202209301843301.png)

3. 删除数据（delete）

   ![image-20220930184520139](https://whymechen.oss-cn-chengdu.aliyuncs.com/image/202209301845289.png)

### DQL

1. 基础查询

   ![image-20220930184903204](https://whymechen.oss-cn-chengdu.aliyuncs.com/image/202209301849223.png)

   ![image-20220930185018702](https://whymechen.oss-cn-chengdu.aliyuncs.com/image/202209301850330.png)

2. 条件查询

   ![image-20220930185806321](https://whymechen.oss-cn-chengdu.aliyuncs.com/image/202209301858782.png)

3. 聚合函数

   ![image-20220930190708198](https://whymechen.oss-cn-chengdu.aliyuncs.com/image/202209301907635.png)

4. 分组查询

   ![image-20220930191026093](https://whymechen.oss-cn-chengdu.aliyuncs.com/image/202209301910187.png)

5. 排序查询

   ![image-20220930191553376](https://whymechen.oss-cn-chengdu.aliyuncs.com/image/202209301915129.png)

   * 使用子句order by对检索出的数据进行排序。

     ~~~sql
     SELECT 列名 FROM 表名 ORDER BY 列名;
     ~~~

     注意：在指定一条order by子句时，应该保证它是select语句中的最后一条子句。否则，会出现错误。

   * 按多个列排序

     ~~~sql
     SELECT 列名 FROM 表名 ORDER BY 列名1,列名2,...;
     ~~~

   * 按列位置排序

   * 指定排序顺序：使用关键字DESC来实现指定降序排序。 

     ~~~sql
     SELECT 列名 FROM 表名 ORDER BY 列名 DESC;
     ~~~

6. 分页查询

   ![image-20220930191951888](https://whymechen.oss-cn-chengdu.aliyuncs.com/image/202209301919617.png)

7. DQL语句执行顺序

   ![image-20220930192506277](https://whymechen.oss-cn-chengdu.aliyuncs.com/image/202209301925589.png)

8. 小结

   ![image-20220930192826816](https://whymechen.oss-cn-chengdu.aliyuncs.com/image/202209301928109.png)

9. 使用

   * 检索单个列

     ~~~sql
     SELECT 列名 FROM 表名;
     ~~~

     注意：SQL语句是不区分大小写的。

     ​			在处理SQL语句时，其中所有空格都是被忽略的。

   * 检索多个列

     ~~~sql
     SELECT 列名1,列名2,.... FROM 表名;
     ~~~

   * 检索所有列

     ~~~sql
     SELECT * FROM 表名;
     ~~~

   * 检索不同的值

     ~~~sql
     SELECT DISTINICT 列名 FROM 表名; 
     ~~~

     注意：distinct关键字作用于所有列，而不是只作用域紧跟其后的一列。

   * 限制结果

     ~~~sql
     //SQL Server和Access中，使用top关键字来限定返回结果的行数
     SELECT TOP 行数 列名 FROM 表名;
     //DB2中
     SELECT 列名 FROM 表名 FETCH FIRST 行数 ROWS ONLY;
     //Oracle中，基于ROWNUM（行计数器）实现
     SELEct 列名 FROM 表名 WHERE ROWNUM <=行数;
     //MySQL、MariaDB、PostgreSQL、SQLite，使用LIMIT子句实现
     SELECT 列名 FROM 表名 LIMIT 行数;
     SELECT 列名 FROM 表名 LIMIT 行数 OFFSET 起始行;//注意：第一个被检索的是0行，而非1行
     ~~~


### DCL

1. 管理用户

   ![image-20220930193235515](https://whymechen.oss-cn-chengdu.aliyuncs.com/image/202209301932090.png)

2. 权限控制

   ![image-20220930193601788](https://whymechen.oss-cn-chengdu.aliyuncs.com/image/202209301936081.png)

   ![image-20220930193701408](https://whymechen.oss-cn-chengdu.aliyuncs.com/image/202209301937630.png)

## 函数

1. 概念：函数是指一段可以直接被另一段程序调用的程序或代码。

2. 字符串函数

   ![image-20221117185754047](https://whymechen.oss-cn-chengdu.aliyuncs.com/image/202211171858195.png)

3. 数值函数

   ![image-20221117190537640](https://whymechen.oss-cn-chengdu.aliyuncs.com/image/202211171905738.png)

4. 日期函数

   ![image-20221117191308114](https://whymechen.oss-cn-chengdu.aliyuncs.com/image/202211171913400.png)

5. 流程函数

   ![image-20221117193120191](https://whymechen.oss-cn-chengdu.aliyuncs.com/image/202211171931769.png)

## 约束

1. 概念：约束是作用于表中字段上的规则，用于限制存储在表中的数据。

2. 目的：保证数据库中数据的正确、有效性和完整性。

3. 分类

   ![image-20221117193229448](https://whymechen.oss-cn-chengdu.aliyuncs.com/image/202211171932772.png)

4. 外键约束

   * 外键用来让两张表的数据之间建立连接,从而保证数据的一致性和完整性。

   * 语法

     ![image-20221117194730658](https://whymechen.oss-cn-chengdu.aliyuncs.com/image/202211171947413.png)

   * 删除/更新行为

     ![image-20221117195653639](https://whymechen.oss-cn-chengdu.aliyuncs.com/image/202211171958957.png)

## 多表查询

1. 多表间基本关系
   * 一对一
   * 一对多
   * 多对多
   
2. 笛卡尔积

   1. 多表查询的分类

   * 连接查询
     * 内连接：相当于查询A、B交集部分数据
     * 外连接
       * 左外连接：查询左表所有数据，以及两张表交集部分数据
       * 右外连接：查询右表所有数据，以及两张表交集部分数据
     * 自连接：当前表与自身的连接查询，自连接必须使用表的别名
     
     > - 内连接（inner join）：取出连接表中匹配到的数据，**匹配不到的不保留**
     > - 外连接（outer join）：取出连接表中匹配到的数据，**匹配不到的也会保留，其值为NULL**
   * 子查询

4. 内连接

   ![image-20221117204115574](https://whymechen.oss-cn-chengdu.aliyuncs.com/image/202211172046948.png)

5. 外连接

   ![image-20221117204620913](https://whymechen.oss-cn-chengdu.aliyuncs.com/image/202211172046393.png)

6. 自连接

   ![image-20221117205212885](https://whymechen.oss-cn-chengdu.aliyuncs.com/image/202211172052309.png)

7. 联合查询

   ![image-20221117205448015](https://whymechen.oss-cn-chengdu.aliyuncs.com/image/202211172054517.png)

8. 子查询

   * 标量子查询(子查询结果为单个值)
     * 常用操作符：=、>=、<=
   * 列子查询(子查询结果为一列
     * 常用的操作符: IN、NOT IN、ANY、 SOME、ALL
   * 行子查询(子查询结果为一行)
   * 表子查询(子查询结果为多行多列

   > 注意：子查询的位置可以在where、from、select之后

## 事务

1. 概念：事务是**一组操作的集合**，它是一个不可分割的工作单位，事务会把所有的操作作为一一个整体一起向系统提交或撤销操作请求，即这些操作要么同时成功，要么同时失败。

   * 保留点：要支持回退部分事务，必须在事务处理块中的合适位置放置占位符，这就是保留点。每个保留点都要取能够标识它的唯一名字，以便在回退时，DBMS知道回退到何处。MySQL中的语句如下：

     >  SAVEPOINT 保留点标识名；

2. 基本操作

   * 方式一：

     ![image-20221117213224636](https://whymechen.oss-cn-chengdu.aliyuncs.com/image/202301131453535.png)

   * 方式二：

     ![image-20221117213306222](https://whymechen.oss-cn-chengdu.aliyuncs.com/image/202211172133460.png)

3. 四大特性(CIAD)

   * 原子性. (Atomicity) ：事务是不可分割的最小操作单元，要么全部成功，要么全部失败。
   * 一致性(Consistency) ：事务完成时，必须使所有的数据都保持一致状态。
   * 隔离性(Isolation)：数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立环境下运行。
   * 持久性(Durability) ：事务一旦提交或回滚，它对数据库中的数据的改变就是永久的。

4. 并发事务

   * 引发的问题

     * 脏读：读到了其他事务未提交的数据。

     * 不可重复读：最开始读到的数据和事务结束前的任意时刻读到的同一批数据出现不一致的情况。

       ![image-20230124094712069](https://whymechen.oss-cn-chengdu.aliyuncs.com/image/202301240947657.png)

     * 幻读

     ![image-20221117214004968](https://whymechen.oss-cn-chengdu.aliyuncs.com/image/202211172140596.png)

   * 事务的隔离级别

     * 类型

       ![image-20221117214200429](https://whymechen.oss-cn-chengdu.aliyuncs.com/image/202211172142141.png)

       > **未提交读(READ UNCOMMITTED)** 事务中的修改，即使没有提交，对其它事务也是可见的。
       >
       >  **提交读(READ COMMITTED)** 一个事务只能读取已经提交的事务所做的修改。换句话说，一个事务所做的修改在提交之前对其它事务是不可见的。
       >  
       >  **可重复读(REPEATABLE READ)** 保证在同一个事务中多次读取同样数据的结果是一样的。
       >  
       >   **可串行化(SERIALIZABLE)** 强制事务串行执行。
       
     * 操作
       ![image-20221117214316834](https://whymechen.oss-cn-chengdu.aliyuncs.com/image/202211172144698.png)
## 存储引擎

### MySQL体系结构

![image-20221118204613913](https://whymechen.oss-cn-chengdu.aliyuncs.com/image/202211182046122.png)

![image-20221118204717244](https://whymechen.oss-cn-chengdu.aliyuncs.com/image/202211182047687.png)

### 存储引擎

1. 存储引擎：存储引擎就是存储数据、建立索弧更新/查询数据等技术的实现方式。**存储引擎是基于表的**，而不是基于库的,所以存储引擎也可被称为表类型。

2. 查看当前数据库支持的存储引擎

   ~~~sql
   show engines;
   ~~~

3. 在创建表时，指定存储引擎

   ~~~sql
   create table 表名(
       # 字段
   	...
   ) engine = INNODB;
   ~~~

4. 存储引擎特点

   * INNODB

     ![image-20221118210239601](https://whymechen.oss-cn-chengdu.aliyuncs.com/image/202211182108215.png)

     ![image-20221118210838607](https://whymechen.oss-cn-chengdu.aliyuncs.com/image/202211182108992.png)

   * MYISAM

     ![image-20221118211056369](https://whymechen.oss-cn-chengdu.aliyuncs.com/image/202211182110733.png)

   * Memory

     ![image-20221118211131982](https://whymechen.oss-cn-chengdu.aliyuncs.com/image/202211182111068.png)

   ![image-20221118211217014](https://whymechen.oss-cn-chengdu.aliyuncs.com/image/202211182112545.png)

   > 注：MySQL中存储引擎为INNODB的表的文件在目录C:\ProgramData\MySQL\MySQL Server 8.0\Data中（Windows），可以通过cmd命令行命令ibd2sdi提取查看文件数据

5. 存储引擎的选择

   ![image-20221118211341200](https://whymechen.oss-cn-chengdu.aliyuncs.com/image/202211182113097.png)

### InnoDB

#### 逻辑存储结构

![image-20230411111557034](https://whymechen.oss-cn-chengdu.aliyuncs.com/image/202304111116203.png)

#### 架构

1. 磁盘结构

![image-20230411111837097](https://whymechen.oss-cn-chengdu.aliyuncs.com/image/202304111121349.png)

![image-20230411112220057](https://whymechen.oss-cn-chengdu.aliyuncs.com/image/202304111122440.png)

![image-20230411112229829](https://whymechen.oss-cn-chengdu.aliyuncs.com/image/202304111122634.png)

![image-20230411112420051](https://whymechen.oss-cn-chengdu.aliyuncs.com/image/202304111124026.png)

![image-20230411113533662](https://whymechen.oss-cn-chengdu.aliyuncs.com/image/202304111135208.png)

![image-20230411113548724](https://whymechen.oss-cn-chengdu.aliyuncs.com/image/202304111135294.png)

![image-20230411113721403](https://whymechen.oss-cn-chengdu.aliyuncs.com/image/202304111137243.png)

2. 后台线程

![image-20230411114127293](https://whymechen.oss-cn-chengdu.aliyuncs.com/image/202304111141878.png)

#### 事务原理

![image-20230411114432339](https://whymechen.oss-cn-chengdu.aliyuncs.com/image/202304111144604.png)

1. redo log

   * Innodb引擎中特有的日志。如果当前使用的引擎是Myisam或者Memory，那就无从谈起redo log。
   * redo log采用的是循环写，为物理日志。

   ![image-20230411115018723](https://whymechen.oss-cn-chengdu.aliyuncs.com/image/202304111150979.png)

2. undo log

   * undo log中记录的是逻辑日志。

   ![image-20230411115159877](https://whymechen.oss-cn-chengdu.aliyuncs.com/image/202304111152107.png)

#### MVCC(多版本并发控制)

参考资料：https://blog.csdn.net/qq_33591903/article/details/120927753

1. 概念

   ![image-20230411174133562](https://whymechen.oss-cn-chengdu.aliyuncs.com/image/202304111741902.png)

2. 隐藏字段

   ![image-20230411174057851](https://whymechen.oss-cn-chengdu.aliyuncs.com/image/202304111740919.png)

3. undo log日志：主要用于事务 回滚时恢复原来的数据

   ![image-20230411174234417](https://whymechen.oss-cn-chengdu.aliyuncs.com/image/202304111742417.png)

4. undo log版本链

   ![image-20230411175020962](https://whymechen.oss-cn-chengdu.aliyuncs.com/image/202304111750144.png)

5. readview

   ![image-20230411175243898](https://whymechen.oss-cn-chengdu.aliyuncs.com/image/202304111752394.png)

   ![image-20230411175326993](https://whymechen.oss-cn-chengdu.aliyuncs.com/image/202304111753962.png)

## 索引

参考：[MySQL数据库索引的类型、命名规范、建立原则以及索引失效的情况](https://blog.csdn.net/u013068184/article/details/107298993/)

### 概述

1. 索引：索引(index)是帮助MySQL高效获取数据的**数据结构**(有序)。

2. 优缺点

   ![image-20221125203610782](https://whymechen.oss-cn-chengdu.aliyuncs.com/image/202211252036399.png)

### 索引结构

1. MySQL的索引是在存储引擎层实现的，不同的存储引擎有不同的结构，主要包含以下几种:

   ![image-20221125203708806](https://whymechen.oss-cn-chengdu.aliyuncs.com/image/202211252037696.png)

   ![image-20221125203802196](https://whymechen.oss-cn-chengdu.aliyuncs.com/image/202211252038644.png)

#### B-Tree

* 特性
  * 允许一个结点包含过个key
  * 对于M阶B树，每个结点最多有M-1个key并以升序排列，每个结点最多有M个子结点，根结点至少有两个子结点。

![image-20221125204507836](https://whymechen.oss-cn-chengdu.aliyuncs.com/image/202211252045218.png)

#### B+树

* 特性：B树的变形
  * 非叶结点仅具有索引作用（即非叶子结点只存储key不存储value）
  * 树的所有叶结点构成一个有序链表，即可以按照key排序的次序遍历全部数据

#### B+树索引

1. 二叉树结构的缺点：顺序插入时，会形成一个链表, 查询性能大大降低。大数据量情况下，层级较深,检索速度慢。

2. 平衡二叉树结构的缺点：大数据量情况下，层级较深，检索速度慢。

4. B+Tree

   * 相对于B-Tree的区别
     * 所有数据都会出现在叶子节点
     * 叶子节点形成一个单向链表

   ![image-20221125204806093](https://whymechen.oss-cn-chengdu.aliyuncs.com/image/202211252048354.png)

5. mysql中的B+Tree：MySQL索引数据结构对经典的B+Tree进行了优化。在原B+Tree的基础. 上,增加一个指向相邻叶子节点的链表指针，就形成了带有顺序指针的B+Tree,提高区间访问的性能。

   ![image-20221125205030347](https://whymechen.oss-cn-chengdu.aliyuncs.com/image/202211252050009.png)

#### Hash索引

1. 哈希索引就是采用一定的hash算法，将键值换算成新的hash值，映射到对应的槽位上,然后存储在hash表中。
2. 特点
   * Hash索引只能用于对等比较(=，in)， 不支持范围查询(between, >，<, ..
   * 无法利用索引完成排序操作
   * 查询效率高，通常只需要- -次检索就可以了 ，效率通常要高于B+tree索引
3. 支持的存储引擎：在MySQL中，支持hash索引的是Memory引擎, 而InnoDB中具 有自适应hash功能，hash索引是存储引擎根据B+Tree索引在指定条件下自动构建的。

### 索引分类

![image-20230124113618926](https://whymechen.oss-cn-chengdu.aliyuncs.com/image/202301241136671.png)

在InnoDB存储引擎中，根据索引的存储形式，又可以分为以下两种：

![image-20230124113741695](https://whymechen.oss-cn-chengdu.aliyuncs.com/image/202301241137594.png)

聚集索引的选取规则：

* 如果存在主键，主键索引就是聚集索引。
* 如果不存在主键，将使用第一价唯一(UNIQUE) 索引作为聚集索引。
* 如果表没有主键，或没有合适的唯一索引， 则InnoDB会自动生成-个rowid作为隐藏的聚集索引。

![image-20230124114228364](https://whymechen.oss-cn-chengdu.aliyuncs.com/image/202301241142549.png)

![image-20230124114341385](https://whymechen.oss-cn-chengdu.aliyuncs.com/image/202301241143026.png)

### 索引语法

![image-20230125221021096](https://whymechen.oss-cn-chengdu.aliyuncs.com/image/202301252210103.png)

> 索引的命名规则：
>
> 一般来说，每家公司可能存在自己的一套规范；也可参照以下的比较通用的索引命名规则（**通过索引类型简写前缀 + 下划线_ + 字段名（组合索引多个字段则继续加_）拼接而成，名称需使用小写字母，同时避免用到MySQL保留关键字**）：
>
> - 唯一索引：使用`uni_[字段名]`来命名，比如用户名唯一索引uni_username
> - 非唯一索引：使用`idx_[字段名]`来命名，比如用户名普通索引idx_username，用户名手机号组合索引idx_username_phone

### 索引使用规则

1. 最左前缀法则

   ![image-20230223182518862](https://whymechen.oss-cn-chengdu.aliyuncs.com/image/202302231825372.png)

2. 范围查询

   ![image-20230223183526784](https://whymechen.oss-cn-chengdu.aliyuncs.com/image/202302231835152.png)

3. 索引列运算

   ![image-20230224103045718](https://whymechen.oss-cn-chengdu.aliyuncs.com/image/202302241030662.png)

4. 字符串不使用引号：字符串类型字段使用时，不加引号，索引将失效。

   ![image-20230224103408045](https://whymechen.oss-cn-chengdu.aliyuncs.com/image/202302241034165.png)

5. 模糊匹配

   ![image-20230224103539825](https://whymechen.oss-cn-chengdu.aliyuncs.com/image/202302241035551.png)

6. or连接的条件

   ![image-20230224103810315](https://whymechen.oss-cn-chengdu.aliyuncs.com/image/202302241038198.png)

7. 数据分布影响

   ![image-20230224104144910](https://whymechen.oss-cn-chengdu.aliyuncs.com/image/202302241041072.png)

8. sql提示

   ![image-20230224104518991](https://whymechen.oss-cn-chengdu.aliyuncs.com/image/202302241045905.png)

9. 覆盖索引

   ![image-20230224105134743](https://whymechen.oss-cn-chengdu.aliyuncs.com/image/202302241051349.png)

10. 前缀索引

    ![image-20230224105850013](https://whymechen.oss-cn-chengdu.aliyuncs.com/image/202302241058045.png)

    ![image-20230224111217203](https://whymechen.oss-cn-chengdu.aliyuncs.com/image/202302241112654.png)

11. 单列索引和联合索引（组合索引）

    * 单列索引:即一个索引只包含单个列。
    * 联合索引:即- -个索引包含了多个列。

    ![image-20230224111919595](https://whymechen.oss-cn-chengdu.aliyuncs.com/image/202302241119060.png)

    > 在业务场景中，如果存在多个查询条件,考虑针对于查询字段建立索引时，建议建立联合索引，而非单列索引。
    >
    > 多条件联合查询时，MySQL优化器会评估哪个字段的索引效率更高，会选择该索引完成本次查询。

### 设计原则

1. 针对于数据量较大,且查询比较频繁的表建立索引。
2. 针对于常作为查询条件(where) 、排序(order by)、分组(group by)操作的字段建立索引。
3. 尽量选择区分度高的列作为索引，尽量建立唯一索引，区分度越高,使用索引的效率越高。
4. 如果是字符串类型的字段,字段的长度较长，可以针对于字段的特点，建立前缀索引。
5. 尽量使用联合索引，减少单列索引，查询时,联合索引很多时候可以覆盖索引，节省存储空间，避免回表,提高查询效率。
6. 要控制索引的数量，索引并不是多多益善，索引越多,维护索引结构的代价也就越大,会影响增删改的效率。
7. 如果索引列不能存储NULL值，请在创建表时使用NOT NULL约束它。当优化器知道每列是否包含NULL值时，它可以更好地确定哪个索引最有效地用于查询。

## 视图

## 存储过程

## 触发器

1. 简介

   * 触发器是与表有关的数据库对象,指在insert/update/delete之前或之后,触发并执行触发器中定义的SQL语句集合。
   * 触发器可以协助应用在数据库端确保数据的完整性,日志记录,数据校验等操作。
   * 使用别名OLD和NEW来引用触发器中发生变化的记录内容,这与其他的数据库是相似的。
   * 现在触发器还只支持行级触发,不支持语句级触发。

2. 类型

   ![image-20230411104801727](https://whymechen.oss-cn-chengdu.aliyuncs.com/image/202304111048749.png)

3. 语法

   ![image-20230411110636030](https://whymechen.oss-cn-chengdu.aliyuncs.com/image/202304111106477.png)

## 锁

参考：https://blog.csdn.net/qq_33591903/article/details/106763311

### 概述

1. 锁：

   锁是计算机协调多个进程或线程并发访问某-资源的机制。 在数据库中，除传统的计算资源(CPU、RAM、I/0) 的争用以外，数据也是一种供许多用户共享的资源。如何保证数据并发访问的一致性、 有效性是所有数据库必须解决的一个问题，锁冲突也是影响数据库并发访问性能的一一个重要因素。

2. 分类

   MySQL中按照锁的粒度进行划分，可以分为三类：

   * 全局锁：锁定数据库中的所有表。
   * 表级锁：每次操作锁住对应的整张表。
   * 行级锁：每次操作锁住对应的数据行。

### 全局锁

1. 概念：

   全局锁就是对整个数据库实例加锁,加锁后整个实例就处于只读状态，后续的DML的写语句，DDL语句，已经更新操作的事务提交语句将被阻塞。其典型的使用场景是做全库的逻辑备份,对所有的表进行锁定,从而获取一致性视图,保证数据的完整性。

2. 操作

   ![image-20230224114941860](https://whymechen.oss-cn-chengdu.aliyuncs.com/image/202302241149276.png)

   > 1. FLUSH TABLES WITH READ LOCk;
   > 2. mysqldump -uroot -p4112 test > D:/test.sql（注意mysqldump并不是mysql中的命令而是工具，所以应该在cmd命令行中执行）
   > 3. UNLOCK tables;

3. 特点

   > 如果在主库上备份，那么在备份期间都不能执行更新，业务基本上就得停摆。
   > 如果在从库.上备份，那么在备份期间从库不能执行主库同步过来的二进制日志(binlog) ,会导致主从延迟。
   >
   > 注意：
   >
   > 在InnoDB引擎中，我们可以在备份时加上参数--single-transaction参数来完成不加锁的一致性数据备份。命令如下：
   > mysqldump --single. .transaction -uroot -p123456 itcast > itcast.sql

### 表级锁

1. 概念：对数据库表进行加锁。锁定粒度大,发生锁冲突的概率最高,并发度最低。应用在MyISAM、InnoDB、 BDB等存储引擎中。

2. 分类

   * 表锁

     * 表共享读锁：读锁不会阻塞其他客户端的读,但是会阻塞写。
     * 表独占写锁：写锁既会阻塞其他客户端的读，又会阻塞其他客户端的写。

     操作语法：

     > 加锁: lock tables表名... read/write。
     > 释放锁: unlock tables /客户端断开连接。

   * 元数据锁（meta data lock,MDL）

     * MDL加锁过程是系统自动控制，无需显式使用，在访问一-张表的时候会自动加上。MDL锁主要作用是维护表元数据的数据一致性, 在表上有活动事务的时候,不可以对元数据进行写入操作。**为了避免DML和DDL冲突，保证读写的正确性。**

     * 查看元数据锁

       > select object_ type,object_ schema,object name,lock_ _type,lock_ duration from performance_ schema.metadata_ _locks ;

     ![image-20230407112041372](https://whymechen.oss-cn-chengdu.aliyuncs.com/image/202304071120409.png)

   * 意向锁

     * 为了避免DML在执行时,加的行锁与表锁的冲突,在InnoDB中引入了意向锁,使得表锁不用检查每行数据是否加锁,使用意向锁来减少表锁的检查。

     * 分类

       * 意向共享锁（IS）：由语句select ... lock in share mode添加。与表锁共享锁(read) 兼容,与表锁排它锁(write) 互斥。.
       * 意向排他锁（IX）：由insert、update、 delete、 select ... for update添加。与表锁共享锁(read) 及排它锁(write) 都互斥。意向锁之间不会互斥。

     * 查看意向锁和行锁加锁情况

       > select object_ schema,object_ name,index_ name,lock_ _type,lock_ mode,lock_ data from performance_ schema.data_ locks;

### 行级锁

1. 概念：

   行级锁，每次操作锁住对应的行数据。锁定粒度最小,发生锁冲突的概率最低,并发度最高。应用在InnoPB存储引擎中。InnoDB的数据是基于索引组织的，行锁是通过对索引.上的索引项加锁来实现的，而不是对记录加的锁。

2. 分类

   * 行锁(Record Lock) ：锁定单个行记录的锁,防止其他事务对此行进行update和delete。在RC、RR隔离级别下都支持。InnoDB实现的行锁：

     * 共享锁（S）：允许一个事务去读一-行， 阻止其他事务获得相同数据集的排它锁。
     * 排他锁（X）：允许获取排他锁的事务更新数据，阻止其他事务获得相同数据集的共享锁和排他锁。

     ![image-20230407153600649](https://whymechen.oss-cn-chengdu.aliyuncs.com/image/202304071536684.png)

     ![image-20230407153634429](https://whymechen.oss-cn-chengdu.aliyuncs.com/image/202304071536658.png)

     > 默认情况下，InnoDB在REPEATABLE READ事务隔离级别运行，InnoDB使用next-key锁进行搜索和索引扫描，以防止幻读。
     > 1. 针对唯一-索引进行检索时,对已存在的记录进行等值匹配时，将会自动优化为行锁。
     > 2. InnoDB的行锁是针对于索引加的锁， 不通过索引条件检索数据，那么InnoDB将对表中的所有记录加锁，此时就会**升级为表锁**。

   * 间隙锁(Gap Lock) ：锁定索引记录间隙(不含该记录)，确保索引记录间隙不变,防止其他事务在这个间隙进行insert,产生幻读**。在RR隔离级别下都支持。**

     > 默认情况下，InnoDB在REPEATABLE READ事务隔离级别运行，InnoDB使用next-key锁进行搜索和索引扫描，以防止幻读。
     > 1. 索引.上的等值查询(唯一 索引), 给不存在的记录加锁时,优化为间隙锁。
     > 2. 索引. 上的等值查询(普通索引),向右遍历时最后一一个值不满足查询 需求时，next-key lock退化为间隙锁。
     > 3. 索引上的范围查询(唯一索引)-- 会访问到不满足条件的第一个值为止。
     >
     > 注意：注意:间隙锁唯一目的是防止其他事务插入间隙。间隙锁可以共存，- -个事务采用的间隙锁不会阻止另一个事务在同一间隙上采用间隙锁。

   * 临键锁(Next-Key Lock) ：行锁和间隙锁组合,同时锁住数据，并锁住数据前面的间隙Gap。**在RR隔离级别下支持**。

## MySQL运维

> 主要包括一些集群架构下的管理操作和技术实现。

### 日志

参考资料：https://blog.csdn.net/qq_33591903/article/details/120517405

1. 类型
   * 错误日志
   * 二进制日志
   * 查询日志
   * 慢查询日志

#### 错误日志

1. 简介

   * 错误日志是 MySQL 中最重要的日志之一，它记录了当 mysqld 启动和停止时，以及服务器在运行过程中发生任何严重错误时的相关信息。
   * 该日志默认开启，且默认存放于/var/log/目录下，文件名为mysqld.log。可通过如下语句查询相关变量获取其存放位置

   ~~~mysql
   SHOW VARIABLES LIKE "%error%"
   ~~~

#### 二进制日志

1. 简介

   * 二进制日志(BINLOG)记录了所有的 DDL(数据定义语言)语句和 DML(数据操纵语言)语句，但不包括数据查询(SELECT、SHOW)语句。（即记录了所有对表的变更操作，包括表中数据和表结构）

   * binlog是追加写入的，一个文件写满，会重新创建一个文件继续写，文件名称是mysql-bin.xxxxxx，例如myql-bin.000001，序号部分会递增。

   * MySQL8中默认开启二进制日志，可通过语句查询相关参数：

     ~~~mysql
     SHOW VARIABLES LIKE "%log_bin%"
     ~~~

2. 使用场景（作用）

   * 灾难时的数据恢复
   * MySQL主从复制

3. 日志查看：由于日志是以二进制方式存储的，不能直接读取，需要通过二进制日志查询工具 mysqlbinlog 来查看，具体语法:

   ~~~mysql
   # log_file_names：要解析的二进制日志文件名，支持多个日志文件名。
   # options：可以指定多个选项来控制工具的行为。
   mysqlbinlog [options] log_file_names
   ~~~

   `--help`显示帮助信息，列出所有可用的选项。

   ```
   bashCopy Codemysqlbinlog --help
   ```

   `--verbose`显示更详细的日志内容，包括事件的原始数据。

   ```
   bashCopy Codemysqlbinlog --verbose binlog.000001
   ```

   `--short-form`以简洁的形式显示事件内容，适合快速查看。

   ```
   bashCopy Codemysqlbinlog --short-form binlog.000001
   ```

   `--start-position`指定从某个位置开始读取二进制日志。位置是一个日志事件的偏移量。

   ```
   bashCopy Codemysqlbinlog --start-position=12345 binlog.000001
   ```

   `--stop-position`指定在某个位置停止读取二进制日志。

   ```
   bashCopy Codemysqlbinlog --stop-position=67890 binlog.000001
   ```

   `--start-datetime` 和 `--stop-datetime`可以用时间范围来筛选日志条目，指定开始和结束的时间。

   ```
   bashCopy Codemysqlbinlog --start-datetime="2025-05-01 10:00:00" --stop-datetime="2025-05-02 18:00:00" binlog.000001
   ```

   `--database`只解析特定数据库的事件。

   ```
   bashCopy Codemysqlbinlog --database=mydb binlog.000001
   ```

   `--rotate`输出当前二进制日志文件的旋转状态。它会输出日志的最后一部分（包含文件名和位置），有助于在 MySQL 复制环境中找到文件的位置。

   ```
   bashCopy Codemysqlbinlog --rotate binlog.000001
   ```

   `--read-from-remote-server`从远程 MySQL 服务器读取二进制日志，而不是本地文件。

   ```
   bashCopy Codemysqlbinlog --read-from-remote-server --host=localhost --user=root --password=your_password binlog.000001
   ```

   `--skip-gtids`跳过 GTID 事件，如果你不想处理全局事务标识符（GTID）日志。

   ```
   bashCopy Codemysqlbinlog --skip-gtids binlog.000001
   ```

   `--result-file`将解析结果输出到文件而不是标准输出。

   ```
   bashCopy Codemysqlbinlog --result-file=output.sql binlog.000001
   ```

   `--xml`以 XML 格式输出二进制日志的内容。

   ```
   bashCopy Codemysqlbinlog --xml binlog.000001
   ```

   `--include-gtids` 和 `--exclude-gtids`指定要包括或排除的 GTID。

   ```
   bashCopy Codemysqlbinlog --include-gtids="GTID1,GTID2" binlog.000001
   ```

4. 日志删除

   对于比较繁忙的业务系统，每天生成的binlog数据巨大，如果长时间不清除，将会占用大量磁盘空间。可以通过以下几种方式清理日志：

   | 清理方法                     | 说明                                                         | 命令或配置                                                   |
   | ---------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
   | **自动清理**                 | 通过配置 `expire_logs_days` 参数，MySQL 自动删除过期日志。   | 在 `my.cnf` 配置文件中添加 `expire_logs_days = 7`            |
   | **手动删除（按日期）**       | 删除指定日期之前的二进制日志文件。                           | `PURGE BINARY LOGS BEFORE '2025-05-01 00:00:00';`            |
   | **手动删除（按日志文件名）** | 删除指定日志文件及其之前的日志文件。                         | `PURGE BINARY LOGS TO 'binlog.000010';`                      |
   | **删除所有日志**             | 删除所有二进制日志文件（例如 `mysql-bin.000001` 之前的所有日志）。 | `PURGE BINARY LOGS TO 'mysql-bin.000001';`                   |
   | **检查当前日志文件**         | 查看当前存在的所有二进制日志文件。                           | `SHOW BINARY LOGS;`                                          |
   | **手动删除文件**             | 在知道日志文件位置的情况下，可以直接删除不再需要的日志文件（不推荐）。 | `rm /path_to_mysql_logs/mysql-bin.000001`                    |
   | **禁用二进制日志**           | 如果完全不需要二进制日志，可以禁用该功能。                   | 在 `my.cnf` 配置文件中注释或删除 `log-bin=mysql-bin`，然后重启 MySQL |

#### 查询日志

1. 简介

   * 查询日志中记录了客户端的所有操作语句，而二进制日志不包含查询数据的SOL语句。默认情况下，查询日志是未开启的。如果需要开启查询日志，可以修改MySQL配置文件`/etc/my.cnf`配置：

     ~~~shell
     #该选项用来开启查询日志，可选值:0或者1;0代表关闭，1代表开启
     general log=1
     #设置日志的文件名，如果没有指定，
     general log file=mysql query.log
     ~~~

#### 慢查询日志

1. 简介

   * 慢查询日志记录了所有执行时间超过参数`long_query_time `设置值并且扫描记录数不小于 `min examined row_limit`
     的所有的SQL语句的日志，默认未开启。`long query time `默认为 10秒，最小为0，精度可以到微秒。可以修改MySQL配置文件`/etc/my.cnf`配置：

     ~~~shell
     #慢查询日志
     slow_query_log=1
     #执行时间参数
     long_query_time=2
     ~~~

   * 默认情况下，不会记录管理语句，也不会记录不使用索引进行查找的查询。可以使用`log_slow_admin_statements`和更改此行为`log queries not using indexes`。

     ~~~shell
     #记录执行较慢的管理语句
     log slow admin statements =1
     #记录执行较慢的未使用索引的语句
     log_queries not using indexes=1
     ~~~

     

### 单库模式

1. 特点
   * 简单粗暴
   * 适用数据量千万以下小型应用
   * 企业网站，创业公司首选
   * 不具备可用性和并发性

### 主从复制

1. 简介

   * 指将主数据库的DDL和 DML操作通过二进制日志传到从库服务器中，然后在从库上对这些日志重新执行(也叫重做)，从而使得从库与主库的数据保持同步。

2. 作用

   * 主库出现问题，可以快速切换到从库提供服务。
   * **实现读写分离，降低主库的访问压力**。
   * 可以在从库中执行备份，以避免备份期间影响主库服务。

3. 原理：binlog日志

   ![image-20250505110229705](https://whymechen.oss-cn-chengdu.aliyuncs.com/image/202505051102474.png)

4. 搭建过程

   * 搭建主从数据库服务器
   * 对主库进行配置
     * 修改配置文件并重启
     * 用户创建与授权
   * 对从库进行配置
     * 修改配置文件并重启
     * 设置主库相关配置：用户、起始位置等

### 分库分表

1. 问题分析：随着互联网及移动互联网的发展，应用系统的数据量也是成指数式增长，若采用单数据库进行数据存储，存在以下性能瓶颈：

   * IO瓶颈:热点数据太多，数据库缓存不足，产生大量磁盘10，效率较低。请求数据太多，带宽不够，网络10瓶颈。
   * CPU瓶颈:排序、分组、连接查询、聚合统计等SOL会耗费大量的CPU资源，请求数太多，CPU出现瓶颈。

   **分库分表的中心思想都是将数据分散存储，使得单一数据库/表的数据量变小来缓解单一数据库的性能问题，从而达到提升数据库性能的目的。**

2. 拆分策略

   * 分库方式
     * 水平分库：将数据按照一定的规则（哈希，用户id取模）分布到不同的数据库中。
     * 垂直分库：将同一库中的多张业务表拆分到多个独立的业务数据库
   * 分表方式

     * 水平分表：使用范围法或hash法将一张大表的数据记录进行分片
       * 为什么水平分表场景下有的大厂禁用自增主键：
         * 原因：自增主键必须连续，只能采用“范围分片”形式，会产生“尾部热点”效应
         * 是否可以使用UUID：不可以，因为UUID是无序的，作为主键会造成大量索引重排
         * 解决方案：雪花算法。但是使用雪花算法需要主要时间回拨带来的影响，可能造成时间回拨的操作一般有两种，一种是人为手动回拨，一种是时钟同步。

     * 垂直分表：将一张大表按”列“拆分为两张以上小表，通过主外键关联来获取数据。
       * 目的：通过将重要字段单独剥离到小表中，让每一页能够容纳更多的行，进行缩小数据扫描范围，达到提高执行效率的目的。
       * 分表依据：单表数据量可能超过千万，字段超过20个，且包含超长的varchar，clob，blob等字段

3. 模式分析

   ![image-20240323175032855](https://whymechen.oss-cn-chengdu.aliyuncs.com/image/202403231750676.png)

4. 分片规则

   * 范围法
   * 根据指定字段及其配置的范围与数据节点对应情况确定数据所属分片
   * 取模分片
     * 根据指定字段值与节点数量进行取模确定数据所属发属分片
     * 数据分配均衡
     * 节点扩展复杂，数据迁移难度大
   * hash法：通过对某个字段（如ID）进行哈希计算，将数据分配到不同的表中。
   * 一致性hash法
     * 相同哈希因子计算值总是被划分到相同的分区表
     * 不会因为分区节点的增加而改变原来数据的位置
   * 枚举分片
   * 业务维度划分
   * 时间分割

5. 主流实现技术：

   * Mycat：数据库分库分表中间件，不用调整代码即可实现分库分表，支持多种语言，性能不及ShardingJDBC。
   * Apache Sharding Sphere：

   | 特征             | Mycat                          | ShardingSphere                     |
   | ---------------- | ------------------------------ | ---------------------------------- |
   | **开发语言**     | Java                           | Java                               |
   | **开源协议**     | GNU GPL                        | Apache License 2.0                 |
   | **社区活跃度**   | 较低                           | 高                                 |
   | **分库分表策略** | 支持水平和垂直分片             | 支持水平和垂直分片                 |
   | **适用场景**     | 适合需要较简单部署和配置的项目 | 适合需要高度灵活性和定制化的项目   |
   | **数据一致性**   | 提供基本的数据一致性保证       | 提供更复杂的数据一致性保证         |
   | **事务支持**     | 支持分布式事务，但配置复杂     | 支持更细粒度的事务管理和XA事务     |
   | **SQL解析**      | 自带SQL解析功能                | 可以集成多种SQL解析器              |
   | **性能**         | 性能较好，适合中小型项目       | 性能较好，可扩展性强，适合大型项目 |
   | **监控与管理**   | 提供基本的监控和管理功能       | 提供完善的监控、管理和运维工具支持 |
   | **生态系统**     | 生态较为有限                   | 生态较为丰富，支持多种数据库和框架 |
   | **扩展性**       | 扩展性一般                     | 扩展性强，支持插件化和定制化       |
   | **部署复杂度**   | 配置和部署相对简单             | 配置和部署较为复杂，但灵活性更高   |

#### Mycat

1. 简介

   ![image-20250505225624465](https://whymechen.oss-cn-chengdu.aliyuncs.com/image/202505052256846.png)

2. 快速使用

   * 搭建多台数据库服务器
   * 配置Mycat配置文件（schema.xml）
   * 配置分片配置文件（server.xml）

3. 配置

   * `schema.xml`
   * `server.xml`

4. 管理

   * 默认使用`8066`（数据访问）、`9066`（数据库管理）两个端口，可通过修改`server.xml`配置文件进行配置修改

#### Apache Sharding Sphere

技术实现：

* Sharding Sphere JDBC：基于AOP原理，在应用程序中对本地执行的SQL进行拦截，解析、改写、路处理。需要自行编码配置实现，只支持java语言，性能较高。
* Sharding Sphere Proxy

### 读写分离

1. 模式分析

   ![image-20240323174354847](https://whymechen.oss-cn-chengdu.aliyuncs.com/image/202403231744943.png)

2. 主从模式

   * 一主一从读写分离
   * 双主双从读写分离
   
3. 特点

   * 架构复杂度和成本提高
   * 需要保证所有节点数据的同步
   * 使用读多写少，单表不过千万的互联网应用
   * 配合MHA中间件方案可实现高可用性

## 常用操作汇总

### 常用命令

~~~ mysql
show databases;//查看当前所有的数据库
use+库名;//打开指定的库
（只要用了use你就在那个库中了）
select database();//查看当前所在库
show tables;//查看当前库所有的表
show tables from 库名;//查看其他库所有的表
create table 表名(
	列名 列类型，
	列名 列类型，
	...
)//创建表
desc 表名;//查看表的结构
查看服务器的版本：
方式一：登录到mysql服务端
select version();
方式二：没有登录到mysql服务端
mysql --version或mysql --V
~~~

### 条件查询

~~~ sql
1.按条件表达式筛选
	条件运算符: > < = != <>(不等于) >= <=
2.按逻辑表达式筛选
	逻辑运算符：&& || !
		    and or not
	作用：连接条件表达式
3.模糊查询
		like(通配符：% 表示任意多个字符		_表示单个任意字符)
		between ... and ...（包含临界值）
		in ...
		is null
~~~

### 排序查询

~~~ sql
select 查询列表 from 表名 [where 筛选条件] order by 排序列表 [ASC|DESC];
说明：
	1. ASC代表升序，DESC代表降序，默认为升序排列
	2、order by子句中可以支持单个字段、多个字段、表达式、函数、别名
	3、order by子句一般是放在查询语句的最后面，limit子句除外
~~~

### 常用函数

~~~sql
select 函数名(实参列表) [from 表(根据需要)];
说明：
	分类：
	1）单行函数（字符函数，数学函数，日期函数，其他函数，流程控制函数）
	如concat、length、ifnull等
	2）分组函数
	功能：做统计使用，又称为统计函数、聚合函数、组函数
	----------------------------------------------------------------
	常见函数：
	字符函数:length  concat substr
	instr trim upper lower
	lpad rpad replace
	
	数学函数： round ceil floor truncate mod
	
	日期函数：now curdate curtime year month monthname 
	day hour minute second str_to_date  date_format
	
	其他函数：version database user
	
	控制函数: if case
~~~

### 分组查询

~~~sql
select 分组函数（max，min这些），列（要求出现在group by后面）
	from 表
	【where 筛选条件】
	group by 分组的列表
	【order by】子句
注意：查询列表必须特殊，要求是分组函数和group by后出现的字段。
	1）分组查询中的筛选条件分为两类（筛选的数据源不同
                        数据源           位置		    关键字
	分组前筛选：    原始表	   group by子句前面	    where
	分组后筛选：分组后的结果集   group by子句后面	    having
	①分组函数做条件，肯定是放在having子句中
	②能用分组前筛选的，优先考虑用分组前筛选
	2）group by子句支持单个字段分组，多个字段分组，
	（多个字段之间用逗号隔开无顺序要求），表达式或函数（用的较少）
	3）可添加排序（放在group by后）
~~~

### 连接查询

~~~sql
1. 连接查询：又称多表查询，当查询的字段来自多个表，就会用到连接查询
2. 分类：
	内连接：等值连接，非等值连接，自连接
	外连接：左外连接，右外连接，全外连接
	交叉连接
3.各连接详细解读
	1）等值连接
    ①多表等值连接的结果为多表的交集部分
    ②n表连接，至少需要n-1个连接条件
    ③多表的顺序无要求
    ④一般需要为表起别名
    ⑤可以搭配前面介绍的所有查询子句使用，比如排序，分组，筛选
    2）非等值连接
    3）自连接
    4）内连接
    select 查询列表
    from 表1 别名
    inner join 表2 别名
    on 连接条件；
    5）外连接
    应用场景：用于查找一个表中有，另一个表中没有的记录
     i.外连接的查询结果为主表中所有的记录
       如果从表中有和它匹配的，则显示匹配的值
       如果从表中没有和它匹配的，则显示null
       外连接查询结果=内连接结果+主表中有而从表中没有的记录
    ii.左外连接：left jon左边的是主表
       右外连接：right join右边的是主表
    iii.左外和右外交换两个表的顺序，可以实现同样的效果
    iV.全外连接=内连接结果+表1有但表2没有+表2有但表1没有
~~~

### 子查询

~~~sql
1.子查询：出现在其他语句内部的select语句，称为子查询或内查询
外部的查询语句，称为主查询或外查询
2.分类：
按子查询出现的位置：
	     select后面：仅仅支持标量子查询
	     from后面：支持表子查询
      ☆ where或者having后面：标量子查询，列子查询，行子查询
	     exists后面（相关子查询）：表子查询
按结果集的行列数不同：
	    标量子查询（结果集只有一行一列）
		列子查询（结果集只有一列多行）
		行子查询（结果集有一行多列）
		表子查询（结果集一般为多行多列）
		
3.解释：
1)where或者having后面
	特点：
①子查询放在小括号内
②子查询一般放在条件右侧
③标量子查询，一般搭配单行操作符使用
> < >= <= = <>
列子查询一般搭配多行操作符使用
IN/NOT IN、ANY/SOME、ALL
④子查询的执行优先于主查询执行
2)select后面
3）from 后面
4）exists后面
~~~

### 分页查询

~~~sql
1.应用场景：当要显示的数据一页显示不全，需要分页提交sql请求
2.语法：
		select 查询列表
		from 表
		【join type join 表2
		where 筛选条件
		group by 分组字段
		having 分组后的筛选
		order by 排序的字段】
		limit offset，size;
	说明：offset:要显示条目的起始索引，起始索引从0开始
		size：要显示的条目数
		①limit语句放在查询语句的最后
		②公式
		要显示的页数 page，每页的条目数size
		select 查询列表
		from 表
		limit (page-1)*size,size;
~~~

### 表数据相关（DML）

~~~sql
1. 插入语句insert
    方式一：insert into 表名(列名,...) values(值1，...);
    方式二：insert into 表名 set 列名=值，列名=值...
2. 删除语句delete
	update 表名
    set 列=新值,列=新值,...
    where 筛选条件;
3. 更新语句update
	delete from 表名 where 筛选条件
~~~

### 数据库或表结构相关（DDL语句）

~~~sql
常见约束

CREATE TABLE 表名(
	字段名 字段类型 列级约束
	字段名 字段类型，
	表级约束
);

含义：一种限制，用于限制表中的数据，为了保证表中数据的准确性和可靠性

分类：六大约束
	not null:非空，用于保证该字段的值不能为空。比如姓名、学号等
	default：默认，用于保证该字段有默认值。比如性别
	primary key：主键，用于保证该字段的值有唯一性，并且非空。比如学号
	unique：唯一，保证该字段的值有唯一性，可以为空。比如座位号
	check：检查约束【mysql不支持】，比如年龄性别
	foreign key：外键，用于限制两个表的关系，保证该字段值必须来自于主表关联列的值
		    在从表添加外键约束，用于引用主表中某列的值
		    比如：员工表的部门编号、工种号

添加约束的时间：
	1、创建表时
	2、修改表时
约束的添加分类：
	1、列级约束：六大约束语法上都支持，但外键约束没有效果
	2、表级约束：除了非空、默认约束，其他都支持
~~~

###  事务

事务：一个或一组sql语句组成一个执行单元，这个执行单元要么全部执行，要么全部不执行。如果单元中某条sql语句一旦执行失败或产生错误，整个单元将会回滚。
~~~sql
/*
事务的创建

1、隐式事务：事务没有明显的开启和结束的标记
比如insert、update、delete语句

delete from 表 where id=1；

2、显式事务：事务具有明显的开启和结束的标记
前提：必须先设置自动提交功能为禁用
SHOW VARIABLES LIKE '%autocommit%';
set autocommit=0;

步骤1：开启事务
set autocommit=0;
start transaction;#可选的

步骤2：编写事务中的sql语句(select,insert,update,delete增删改查，不包括create，drop这些)
语句1;
语句2;
...

步骤3：结束事务
commit;提交事务
rollback;回滚事务
save point 节点名;#设置保存点

*/

CREATE DATABASE test;

CREATE TABLE account(
	id INT PRIMARY KEY AUTO_INCREMENT,
	username VARCHAR(20),
	balance DOUBLE
);
INSERT INTO account(username,balance)
VALUES('张无忌',1000),('赵敏',1000);

#演示事务的使用步骤
SET autocommit=0;
#编写一组事务的语句
UPDATE account SET balance=500 WHERE username='张无忌';
UPDATE account SET balance=1500 WHERE username='赵敏';

#结束事务
#commit;
ROLLBACK;#把500,1500改成1000,1000，执行回滚，发现还是500,1500

SELECT * FROM account;

#演示savepoint的使用
SET autocommit=0;
START TRANSACTION;

DELETE FROM account WHERE id=1;
SAVEPOINT a;#设置保存点
DELETE FROM account WHERE id=2;

ROLLBACK TO a;#回滚到保存点
SELECT * FROM account;#1号删了，2号没删
~~~

### 存储过程

含义：
一组预先编译好的sql语句的集合，理解成批处理语句

好处：
1、提高代码的重用性
2、简化操作
3、减少了编译次数，并且减少了和数据库服务器的连接次数，提高了效率

~~~sql
#一、创建语法

CREATE PROCEDURE 存储过程名(参数列表)
BEGIN
	存储过程体（一组合法的SQL语句）
END

注意：
1、参数列表包含三部分
参数模式 参数名 参数类型
举例：
IN stuname VARCHAR(20)

参数模式：
IN:该参数可以作为输入，即需要调用方传入值
OUT:参数可以作为输出，即可以作为返回值
INOUT:该参数既可以作为输入又可以作为输出，也就是既需要传入值，又可以返回值

2、如果存储过程体只有一句话, BEGIN END 可以省略
存储过程体中每条sql语句结尾必须加分号
存储过程的结尾可以使用 DELIMITER 重新设置
语法：
DELIMITER 结束标记
例如：
DELIMITER $

#二、调用语法
CALL 存储过程名(实参列表);
~~~

### 函数

~~~sql
#一、创建语法
CREATE FUNCTION 函数名(参数列表) RETURNS 返回类型
BEGIN
	函数体
END
/*
注意：
1、参数列表包含两部分-----参数名 参数类型

2、函数体：肯定会有return语句，如果没有会报错
如果return语句没有放在函数体最后也不报错，但不建议

return 值;

3、当函数体只有一句话可以省略begin，end

4、使用delimiter语句设置结束标记

*/

#二、调用语法
SELECT 函数名(参数列表)
~~~

### 代码示例

~~~sql
# 1.query one field from a table
select last_name from employees;

# 2.query fields from a table
select last_name,salary,email from employees;

# 3.query all fields from a table
select * from employees;

# 4.query const values
select 100;

-- 5.give an alias
# use as for the keyword
select last_name as 姓 from employees;
select last_name 姓 from employees;

# 6. 去重
# 查询员工表中所有涉及到的部门编号
select distinct department_id from employees;

# 查询员工姓和名连接成一个字段，并显示为姓名
select concat(last_name,first_name) 姓名 from employees;
# 判断是否为空,为空返回0
select IFNULL(commission_pct,0) 奖金率,commission_pct from employees;

======================================================================
-- 1. 查询工资>12000的员工信息
select * from employees where salary>12000;

-- 2. 查询部门编号不等于90号的员工名和部门编号
select last_name,department_id from employees where department_id!=90;

-- 3. 查询工资在10000到20000之间的员工名，工资和奖金
select 
	last_name,
	salary,
	commission_pct
from
	employees
where
	salary between 10000 and 20000;
	

select 
	last_name,
	salary,
	commission_pct
from
	employees
where
	salary>=10000 and salary<=20000;
	
	-- 4. 查询部门编号不在90-110之间，或者工资高于15000的员工信息
	select
		*
	from 
		employees
	where
		department_id not in(90,110) or salary>15000;
		
	select
		*
	from 
		employees
	where
		department_id<90 or department_id>110 or salary>15000;
		
-- 5. 查询员工名中包含字符a的员工信息
	select * from employees where last_name like '%a%';
	
-- 6. 查询员工名中第3个字符为n，第五个字符为l的员工名和工资
	select
		last_name,
		salary
	from
		employees
	where
		last_name like '__n_l%';
		
-- 7. 查询员工名中第二个字符为_的员工名（转义字符）
	select
		last_name
	from
		employees
	where
		last_name like '_\_%';
		
-- 8. 查询员工编号在100到120之间的员工信息
	select
		*
	from
		employees
	where
		employee_id between 100 and 120;
		
		
-- 9. 查询员工的工种编号是 IT_PROT, AD_VP, AD_PRES中的一个的员工名和工种编号
	select
		last_name,
		job_id
	from
		employees
	where
		job_id in('IT_PROT', 'AD_VP','AD_PRES');
		
		
-- 10. 查询没有奖金的员工名和奖金率
	select
		last_name,
		commission_pct
	from
		employees
	where
		commission_pct is null;
#安全等于  <=>  is null可以换成<=> null

-- 11. 查询员工信息，要求工资从高到低排序
select * from employees order by salary DESC;

-- 12. 查询部门编号>=90的员工信息，按入职时间的先后进行排序
select * from employees where department_id>=90 order by hiredate;

-- 13. 按年薪高低显示员工的信息和年薪[按表达式排序]
select *,12*salary 年薪 from employees order by 12*salary;

-- 14. 按姓名的长度显示员工的姓名和工资 [按函数排序]
select last_name,salary from employees order by LENGTH(last_name);

-- 15.查询员工信息，要求先按工资升序，再按员工编号降序 [按多个字段排序]
select * from employees order by salary ASC,employee_id DESC;


-- 16.length 获取参数值的字节个数
select length('hnon');

-- 17.concat 拼接字符串（用下划线拼接）
select concat(last_name,'.',first_name) from employees;

-- 18.变大写，变小写
select upper('tom');
select lower('TOM');

-- 19.substr,substring
# 注意：索引从1开始
select substr('chenwenjian',5);
select substr('chenwenjian',5,3);

-- 20.instr 返回子串的起始索引，找不到返回0
select instr('chenwenjian','wenjian');

-- 21.trim 去掉首尾指定字符
select trim('          chenwenjian     ');
select trim('a'from'aaa aabbbchenwenjianbbbbaaa');

-- 22.lpad 用指定的字符实现左填充指定长度
select lpad('chenwenjian',20,'**');

-- 23.rpad  用指定的字符实现右填充指定长度
select rpad('chen',10,'++++');

-- 24.replace 替换
select replace('chenwenjian','wen','whymechen');

-- 25.round 四舍五入
select round(3.14);
#1.57,小数点后保留2位
SELECT ROUND(1.567,2);

-- 26. ceil 向上取整，返回>=该参数的最小整数
select ceil(5.6);

-- 27.floor 向下取整，返回<=该参数的最大整数
select floor(5.6);

-- 28.truncate 截断
select truncate(1.6897438297423,5);

-- 29.mod 取余
select mod(10,-3);

-- 30.now 返回当前系统日期加时间
select now();

-- 31.curdate 返回当前系统日期，不包含时间
select curdate();

-- 32.返回当前系统日期，不包含时间
select year(now());

-- 33.str_to_date 将日期格式字符串转换成指定格式日期
-- %Y 四位的年份
-- %y 2位的年份
-- %m 月份 （01,02，...12）
-- %c 月份（1,2，..., 12）
-- %d 日
-- %H小时（24）%h（12）
-- %i 分钟  %s秒
select str_to_date('2020-5-8','%Y-%m-%d');

-- 33.date_format 将日期转换成字符
select date_format(now(),'%Y/%m/%d');

-- 34.if
select if(6>9,'true','false');

-- 35.查询员工的工资：要求
-- 部门号=30，显示的工资为1.1倍
-- 部门号=40，显示的工资为1.2倍
-- 部门号=50，显示的工资为1.3倍
-- 其他部门显示原工资
SELECT salary,department_id,
CASE department_id
WHEN 30 THEN salary*1.1
WHEN 40 THEN salary*1.2
WHEN 50 THEN salary*1.3
ELSE salary
END AS 新工资
FROM employees;

-- 36.sum 求和、avg平均值、max、min、count计算个数
select sum(salary) from employees;
select avg(salary) from employees;
select max(salary) from employees;
SELECT min(salary) from employees;
select count(salary) from employees;

-- 37.查询每个工种的最高工资
select max(salary),job_id from employees group by job_id;

-- 38.查询每个位置上的部门个数
select count(*),department_id from departments group by location_id;

-- 39.查询邮箱中包含a字符的，每个部门的平均工资
select avg(salary) from employees where email like '%a%' group by department_id;
-- select avg(salary) from employees group by department_id having email like '%a%';

-- 40.查询有奖金的每个领导手下员工的最高工资

-- 41.查询哪个部门的员工个数大于2
select department_id,count(*) from employees group by department_id having count(*)>2;

-- 42.查询员工名和对应的部门名
select last_name,department_name from employees,departments where employees.department_id=departments.department_id;

-- 43.查询员工名和上级的名称
select e.last_name 员工名字,m.last_name 上级名字 from employees e,employees m where e.manager_id=m.department_id;

-- 44.查询员工名，部门名
select e.last_name,d.department_name from employees e inner join departments d on e.department_id=d.department_id;

-- 45.查询部门个数>3的城市名和部门个数（添加分组+筛选）
select l.city,count(*) 部门个数 
from departments d 
inner join locations l 
on d.location_id=l.location_id 
group by city 
having count(*)>3;

-- 46.查询哪个城市没有部门
select locations.city from locations left join departments on departments.location_id=locations.location_id where departments.department_id is null;


-- 47.谁的工资比Abel高
select last_name from employees where salary>(select salary from employees where last_name='Abel');

-- 48.返回job_id与141号员工相同，salary比143号员工多的员工姓名，
-- job_id和工资
select last_name,job_id,salary from employees where salary>(select salary from employees where employee_id=143) and job_id=(select job_id from employees where employee_id=141);

-- 49.返回location_id是1400或1700的部门中所有员工姓名
select last_name from employees where department_id in(select distinct department_id from departments where location_id=1400 or location_id= 1700);

-- 49.返回其他工种中比job_id为‘IT_PROG'部门任一工资低的员工信息
select * from employees where salary<all(select distinct salary from employees where job_id='IT_PROG') and job_id <> 'IN_PROG';

-- 50.查询员工编号最小并且工资最高的员工信息
select * from employees where employee_id=(select min(employee_id) from employees) and salary=(select max(salary) from employees);

-- 51.查询每个部门的员工个数
select department_name,(select count(*) from employees where employees.department_id=departments.department_id) from departments;

-- 52.查询有员工的部门名
select department_name from departments where exists(select * from employees where departments.department_id=employees.department_id);

-- 53.查询第11条——第25条员工信息
select * from employees limit 11,15; 
~~~

## 操作Json数据

参考：

* [mybatis plus使用mysql中的json类型数据]([mybatis plus使用mysql中的json类型数据 (1024s.top)](http://1024s.top/blog/detail?blogId=49772))

示例表结构：

~~~sql
CREATE TABLE `json_test`(
id BIGINT NOT NULL AUTO_INCREMENT COMMENT 'id',
roles JSON DEFAULT NULL COMMENT '角色',
project JSON DEFAULT NULL COMMENT '项目',
PRIMARY KEY(id)
);
~~~

### 数据插入

可以通过 INSERT INTO 语句将 JSON 数据插入到表中。

~~~sql
INSERT INTO my_table (json_column) VALUES ('{"key": "value"}');

INSERT json_test(roles,project) VALUES('[{"id":10001,"name":"管理员"},{"id":10002,"name":"开发"},{"id":10003,"name":"测试"}]','{"id": 11111, "name": "项目1"}');
~~~

也可以使用函数json_object，进行数据新增。

~~~sql
insert into user_test(user_name, details) values
('lily', JSON_OBJECT("phone","18500001111", "sex",1,"age",46,"email","1233@qq.com", "address",JSON_OBJECT("country","CN","province","上海市","city","上海市")));
~~~

还可以使用函数`JSON_INSERT(json_doc,path,val[,path,val]...)`仅当指定位置或指定key的值不存在时，才执行插入操作。

~~~sql
select json_insert('1','$[0]',"10");
~~~

### 数据查询

可以使用 `->` 或 `->>` 运算符来查询 JSON 字段的值。

* `->` 返回一个 JSON 对象或数组
* `->>` 返回一个字符串。

~~~sql
SELECT json_column->"$.key" AS value FROM my_table;
SELECT json_column->>"$.key" AS value FROM my_table;
~~~

可以使用 `->>` 运算符在 WHERE 子句中查询 JSON 字段的值。例如：

```sql
SELECT * FROM my_table WHERE json_column->>"$.key" = 'value';
```

还可以使用函数`json_extract(json_doc,path[,path]...)`其中，json_doc 是 JSON 文档，path 是路径。该函数会从 JSON 文档提取指定路径（path）的元素。如果指定 path 不存在，会返回 NULL。可指定多个 path，匹配到的多个值会以数组形式返回。

> `->`和`->>`都是语法糖，在实际使用的时候都会转化为JSON_EXTRACT

~~~sql
select json_extract('[10, 20, [30, 40]]', '$[2]');

select json_extract('[10, 20, [30, 40]]', '$[0 to 1]');

select json_extract('[10, 20, [30, 40]]', '$[*]');
~~~



### 数据更新

可以使用 `JSON_SET` 函数来更新 JSON 数据的特定字段。例如：

```sql
UPDATE my_table SET json_column = JSON_SET(json_column, "$.key", "new_value") WHERE id = 1;
```

`json_replace(json_doc,path,val[,path,val]...)`替换已经存在的值。

### 数据删除

可以使用 `JSON_REMOVE` 函数来删除 JSON 数据中的特定字段。例如：

```sql
UPDATE my_table SET json_column = JSON_REMOVE(json_column, "$.key") WHERE id = 1;
```

## 性能调优

数据库性能调优核心内容如下：

1. **硬件层面**
   * **CPU**：确保数据库服务器的CPU足够强大，考虑使用更高频率、更多核心的处理器。
   * **内存**：增加内存，减少磁盘I/O瓶颈。更多内存有助于更多数据存入内存缓存，减少磁盘读取。
   * **磁盘**：选择性能更好的磁盘，如固态硬盘（SSD），避免使用传统硬盘（HDD）。
   * **网络**：确保数据库服务器的网络连接快速稳定，避免因网络延迟或带宽瓶颈导致性能问题。
2. **数据库配置**
   * **缓存配置**：合理设置数据库的缓存（如 MySQL 的 `innodb_buffer_pool_size`）以减少磁盘I/O。
   * **连接池**：优化数据库连接池的大小，避免过多或过少的连接。
   * **数据库实例数量**：根据需求决定数据库实例的数量，避免过多实例引起资源争用。
   * **并发处理**：调整数据库并发设置，确保能够处理多个并发查询。
3. **SQL 查询优化**
   * **索引优化**：为常用的查询列添加索引，但避免过多冗余索引，因为每个索引都会影响写操作性能。
   * **查询重写**：重构复杂或不高效的查询，使用 `EXPLAIN` 分析查询计划，优化查询执行路径。
   * **避免全表扫描**：尽量避免查询中没有索引的列，以减少全表扫描的开销。
   * **避免不必要的子查询**：使用连接（JOIN）代替不必要的子查询，减少查询复杂度。
   * **批量处理**：使用批量操作代替多次单条数据操作，提高性能。
4. **数据结构设计**
   * **表设计**：确保表设计合理，避免过度规范化或冗余数据。
   * **数据分区**：对于大表，可以采用分区（Partitioning）或分表策略，减少单个表的数据量，提高查询效率。
   * **规范化与反规范化**：根据需求选择合适的数据库规范化程度，减少数据冗余，提高性能。
   * **字段类型优化**：选择合适的字段数据类型，避免使用过大或不必要的类型。
5. **索引优化**
   * **适当索引**：为查询条件中的字段、JOIN条件字段以及WHERE、ORDER BY中的字段建立索引。
   * **复合索引**：当多个列常常一起查询时，使用复合索引来提高查询效率。
   * **索引覆盖**：创建索引时，尽量使查询能够通过索引本身就能获取所需数据，而无需访问表数据。
   * **删除无效索引**：删除不常用或冗余的索引，减少写操作时的开销。
6.  **数据库维护**
   * **定期清理**：定期清理不再需要的数据或过时记录，减轻数据库负担。
   * **表统计信息更新**：定期更新表的统计信息，确保数据库优化器能做出最佳的查询执行计划。
   * **碎片整理**：对于使用磁盘存储的数据库（如 MySQL），定期进行碎片整理，避免磁盘空间被浪费。
7.  **并发和锁优化**
   * **事务隔离级别调整**：根据需要调整事务隔离级别，避免不必要的锁等待。
   * **死锁监控**：监控和分析死锁，优化锁的使用，避免死锁现象。
   * **乐观锁/悲观锁**：根据业务场景合理选择乐观锁（如基于版本的控制）或悲观锁（如使用数据库锁）。
8. **数据库架构优化**
   * **读写分离**：采用主从复制架构，将读请求分配给从库，减轻主库的负担。
   * **分布式数据库**：根据需求选择分布式数据库架构，例如分库分表、Sharding 等。
   * **高可用架构**：使用数据库集群或高可用方案（如 MySQL 的主从、Galera Cluster）提高数据库的可用性和性能。
9.  **缓存优化**
   * **应用层缓存**：使用 Redis、Memcached 等缓存系统缓存频繁查询的数据，减少数据库访问次数。
   * **查询结果缓存**：缓存查询结果，对于不常变化的数据可以大大减少数据库的负载。
   * **合理过期策略**：设置合适的缓存过期时间，确保缓存中的数据是新鲜的。
10. **日志和监控**
    * **慢查询日志**：开启并分析慢查询日志，识别并优化性能瓶颈的查询。
    * **性能监控**：使用数据库监控工具（如 Prometheus、Zabbix 等）实时监控数据库的性能指标，如查询响应时间、I/O负载等。
    * **日志优化**：减少日志的写入量，特别是在生产环境中，避免日志占用过多资源。
11.  **事务与锁管理**
    * **事务粒度控制**：尽量缩小事务的范围，避免长时间占用锁。
    * **非阻塞操作**：设计无锁或减少锁等待的数据库操作，提升并发性能。
12.  **数据库版本升级与优化**

- **数据库版本更新**：确保数据库运行在最新稳定版本，利用新版本的性能优化和新特性。
- **应用与数据库的适配性**：确保应用程序和数据库版本的兼容性，避免由于不兼容导致的性能问题。

### SQL性能分析

1. SQL执行频率

   ![image-20230223103331778](https://whymechen.oss-cn-chengdu.aliyuncs.com/image/202302231033899.png)

   > com后一个_表示一类操作

2. 慢查询日志

   ![image-20230223103611305](https://whymechen.oss-cn-chengdu.aliyuncs.com/image/202302231130225.png)

3. profiles详情

   ![image-20230223113419776](https://whymechen.oss-cn-chengdu.aliyuncs.com/image/202302231134047.png)

   ![image-20230223113655909](https://whymechen.oss-cn-chengdu.aliyuncs.com/image/202302231136148.png)

4. **ecplain执行计划**

   ![image-20230223113824864](https://whymechen.oss-cn-chengdu.aliyuncs.com/image/202302231138612.png)

   ![image-20230223115318090](https://whymechen.oss-cn-chengdu.aliyuncs.com/image/202302231808259.png)

   ![image-20230223180744379](https://whymechen.oss-cn-chengdu.aliyuncs.com/image/202302231807951.png)

# 参考资料

书籍：

* 《高性能MySQL》
* 《SQL必知必会》

网站：

* https://www.percona.com/blog/#

练习：

* 常用SQL语句练习案例链接：https://www.cnblogs.com/Diyo/p/11424844.html
* 牛客网：https://www.nowcoder.com/
* 力扣