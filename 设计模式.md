设计模式

## 1.概述

### 1.1 软件设计模式产生背景

### 1.2 什么是设计模式

一般来说，一个模式有四个基本要素：

* 模式名称
* 问题
* 解决方案
* 效果

### 1.3 描述设计模式

1. 模式名和分类
2. 意图
3. 别名
4. 动机
5. 适用性
6. 结构
7. 参与者
8. 协作
9. 效果
10. 实现
11. 代码示例

### 1.4 模式的分类

![image-20210419222737415](C:\Users\hp\AppData\Roaming\Typora\typora-user-images\image-20210419222737415.png)

* 创建型模式：用于描述“怎样创建对象”，主要她特点是“将对象的创建与使用分离”
* 结构型模式：用于描述如何将类或对象按照某种布局组成更大的结构
* 行为型模式：用于描述对象和类之间怎样相互协作共同完成单个对象无法完成的任务，以及怎样分配职责

### 1.5 怎样选择设计模式

### 1.6 统一建模语言UML

#### 1.6.1 类图

1. 表示方法 

2. 类与类之间的关系

   * 关联关系

     * 单向关联

       ![image-20210515105214769](C:\Users\hp\AppData\Roaming\Typora\typora-user-images\image-20210515105214769.png)

     * 双向关联

       ![image-20210515105356738](https://cdn.jsdelivr.net/gh/whyme-chen/Image/imgimage-20210515105356738.png)

     * 自关联

       ![image-20210515105433111](C:\Users\hp\AppData\Roaming\Typora\typora-user-images\image-20210515105433111.png)

   * 聚合关系

     ![image-20210515105702450](C:\Users\hp\AppData\Roaming\Typora\typora-user-images\image-20210515105702450.png)

   * 组合关系

     ![image-20210515105806583](C:\Users\hp\AppData\Roaming\Typora\typora-user-images\image-20210515105806583.png)

   * 依赖关系

     ![image-20210515110448163](C:\Users\hp\AppData\Roaming\Typora\typora-user-images\image-20210515110448163.png)

   * 继承关系

     ![image-20210515110549386](C:\Users\hp\AppData\Roaming\Typora\typora-user-images\image-20210515110549386.png)

   * 实现关系

     ![image-20210515110648090](C:\Users\hp\AppData\Roaming\Typora\typora-user-images\image-20210515110648090.png)

### 1.7 软件设计原则

#### 1. 开放封闭原则

对扩展开放，对修改关闭。

#### 2. 里氏代换原则

任何积累可以出现的地方，子类一定可以出现。

#### 3. 依赖倒转原则

高层模块不应该依赖底层模块，两者都应该依赖其抽象；抽象不应该依赖细节，细节应该依赖抽象。简单的理解就是要求对抽象进行编程，不要对实现进行编程，降低客户与实现模块之间的耦合。

#### 4.接口隔离原则

客户端不应该被迫依赖于它不使用的方法：一个类对另一个类的依赖应该建立在最小的接口上。

#### 5. 迪米特原则

如果两个软件无需直接通信，就不应该发生直接的相互调用，可以通过第三方转发该调用。

#### 6. 合成复用原则

尽量先使用组合或者聚合的等关联关系来实现，其次才考虑使用继承关系来实现。

#### 7. 单一职责原则

## 2.创建者模式（5种）

### 工厂方法

1. 概念：定义一个用于创建对象的接口，让子类决定实例化哪个产品类对象。工厂方法使一个产品类的实例化延迟到其工厂的子类。
2. 结构（主要角色）
   * 抽象工厂
   * 具体工厂
   * 抽象产品
   * 具体产品
3. 使用场景
4. 优缺点
   * 优点：用户只需要知道具体工厂的名称就可以得到所需要的的产品，无须知道产品的具体创建过程。在系统增加新的产品时只需要添加具体产品类和对应具体工厂类，无须对原工厂进行任何修改，满足开放封闭原则。
   * 缺点：每增加一个产品就要增加一个具体的产品类和一个对应的具体工厂类，这增加了系统的复杂度。

### 抽象工厂

1. 概念：是一种为访问类提供一个创建一组相关或相互依赖对象的接口，且访问类无须指定所要产品的具体类就能得到同组的不同等级的产品的模式结构。

2. 结构

   * 抽象工厂

   * 具体工厂

   * 抽象产品

   * 具体产品

     ![image-20210609103835419](C:\Users\hp\AppData\Roaming\Typora\typora-user-images\image-20210609103835419.png)

3. 使用场景

   *  如果代码需要与多个不同系列的相关产品交互， 但是由于无法提前获取相关信息， 或者出于对未来扩展性的考虑， 你不希望代码基于产品的具体类进行构建， 在这种情况下， 你可以使用抽象工厂。
   * 如果你有一个基于一组抽象方法的类， 且其主要功能因此变得不明确， 那么在这种情况下可以考虑使用抽象工厂模式。

4. 优缺点

   * 优点：可以确保同一工厂生产的产品相互匹配。可以避免客户端和具体产品代码耦合。满足单一职责厕原则和开放封闭原则。
   * 缺点：使系统更加复杂。

### 建造者模式

### 单件模式

1. 概念：这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。
2. 结构
   * 单例类
   * 访问类
3. 实现
   * 饿汉式：类加载就会导致该单实例对象被创建。可以用静态变量或静态代码块、枚举类的方式实现
   * 懒汉式：类加载不会导致该单实例对象被创建，而是首次使用该对象时才会创建。存在线程不安全，线程安全和双重检查所锁，静态内部类四种方式。

### 原型模式

## 3.结构型模式（7种） 

## 4. 行为型模式（11种）



