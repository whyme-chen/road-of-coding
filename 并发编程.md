# 并发编程（java)

## 基本概念

1. 进程与线程
   * Java中，线程作为最小调度单位,进程作为资源分配的最小单位。
   * 在windows中进程是不活动的，只是作为线程的容器
2. 并发与并行
   * 并发：在同一时间段内多个线程同时运行（微观并发，宏观并行）
   * 并行：在同一时刻同时进行
3. 同步与异步
   * 同步：需要等待结果返回，才能继续运行
   * 异步：不需要等待结果返回，就能继续运行

## Java线程

### 创建和运行线程

1. 方法一：通过继承Thread类创建
2. 方法二：通过实现Runnable接口创建
3. 方法三：通过实现Callable接口配合FutureTask类创建

```
package com.whymechen.demo;

import java.util.concurrent.Callable;
import java.util.concurrent.FutureTask;

/**
 *
 * @Author chen
 * @Date 2023/4/15
 * @Version 1.0
 **/
public class ThreadDemo {
    public static void main(String[] args) {
        Thread printThread1 = new Thread("printThread1"){
            @Override
            public void run() {
                System.out.println("thread........");
            }
        };
        printThread1.start();

        System.out.println("main.............");

        Thread printThread2 = new Thread(new Runnable() {
            @Override
            public void run() {
                System.out.println("Runnable........");
            }
        },"printThread2");
        printThread2.start();

        /*Lambda表达式*/
        Thread printThread3 = new Thread(() -> {System.out.println("Runnable2........");},
                "printThread3");
        printThread3.start();


        FutureTask<Object> futureTask = new FutureTask<>(new Callable<Object>() {
            @Override
            public Object call() throws Exception {
                System.out.println("Callable+FutureTask.......");
                return 1;
            }
        });

        Thread printThread4 = new Thread(futureTask,"printThread4");
        printThread4.start();
    }

}
```

### 进程线程查看

1. Windows
   * 任务管理器可以查看进程和线程数，也可以用来杀死进程
   * tasklist 查看进程
   * taskkill 杀死进程
2. Linux
   * ps -fe 查看所有进程
   * ps -fT -p <PID> 查看某个进程（PID）的所有线程
   * kill 杀死进程
   * top 按大写 H 切换是否显示线程
   * top -H -p <PID> 查看某个进程（PID）的所有线程
3. java
   * jps 命令查看所有 Java 进程
   * jstack <PID> 查看某个 Java 进程（PID）的所有线程状态
   * jconsole 来查看某个 Java 进程中线程的运行情况（图形界面）

### 线程运行原理

#### 栈与栈帧

 JVM 中由堆、栈、方法区所组成，每个线程启动后，虚拟机就会为其分配一块栈内存。

* 每个栈由多个栈帧（Frame）组成，对应着每次方法调用时所占用的内存
* 每个线程只能有一个活动栈帧，对应着当前正在执行的那个方法

![image-20230415175008833](https://whymechen.oss-cn-chengdu.aliyuncs.com/image/202304151750294.png)

#### 线程上下文切换

1. 切换条件
   * 线程的 cpu 时间片用完
   * 垃圾回收
   * 有更高优先级的线程需要运行
   * 当前线程主动放弃执行，比如调用了 sleep、yield、wait、join、park、synchronized、lock 等方法
2. 切换过程
   * 当 Context Switch 发生时，需要由操作系统保存当前线程的状态，并恢复另一个线程的状态，Java 中对应的概念就是程序计数器（Program Counter Register）
   * 程序计数器的作用是记住下一条 jvm 指令的执行地址，是线程私有的，状态包括程序计数器、虚拟机栈中每个栈帧的信息，如局部变量、操作数栈、返回地址等

### 常用方法

| 方法名           | static | 功能                                            | 其他说明                                                     |
| ---------------- | ------ | ----------------------------------------------- | ------------------------------------------------------------ |
| start()          |        | 启动一个新线程，在新的线程运行 run 方法中的代码 | start 方法只是让线程进入就绪，里面代码不一定立刻运行（CPU 的时间片还没分给它）。每个线程对象的start方法只能调用一次，如果调用了多次会出现IllegalThreadStateException |
| run()            |        | 新线程启动后调用的方法                          | 如果在构造 Thread 对象时传递了 Runnable 参数，则线程启动后会调用 Runnable 中的 run 方法，否则默认不执行任何操作。但可以创建 Thread 的子类对象，来覆盖默认行为 |
| join()           |        | 等待线程运行结束                                |                                                              |
| join(long n)     |        | 等待线程运行结束,最多等待 n 毫秒                |                                                              |
| interrupt()      |        | 中断线程                                        | 如果被打断线程正在 sleep，wait，join 会导致被打断的线程抛出InterruptedException，并清除 打断标记 ；如果打断的正在运行的线程，则会设置 打断标记 ；park 的线程被打断，也会设置 打断标记 |
| sleep(long n)    | static | 让当前线程休眠                                  | 让当前执行的线程休眠n毫秒，休眠时让出 cpu 的时间片给其它线程 |
| yield（）        | static | 提示线程调度器让出当前线程对CPU的使用           | 主要是为了测试和调试                                         |
| getId()          |        | 获得线程唯一的长整型id                          |                                                              |
| getName()        |        | 获取线程名                                      |                                                              |
| setName（）      |        | 设置线程名                                      |                                                              |
| getPriority（）  |        | 获取线程优先级                                  |                                                              |
| setPriority(int) |        | 设置线程优先级                                  | java中规定线程优先级是1~10 的整数，较大的优先级能提高该线程被 CPU 调度的机率 |
| getState()       |        | 获取线程状态                                    | Java 中线程状态是用 6 个 enum 表示，分别为：NEW, RUNNABLE, BLOCKED, WAITING, TIMED_WAITING, TERMINATED |
| isInterrupted()  |        | 判断是否被打断                                  | 不会清除打断标记                                             |
| isAlive()        |        | 线程是否存活                                    |                                                              |
| interrupted()    | static | 判断当前线程是否被中断                          | 会清除中断标记                                               |
| currentThread()  | static | 获取当前正在执行的线程                          |                                                              |

1. run和start

   * 直接调用 run 是在主线程中执行了 run，没有启动新的线程
   * 使用 start 是启动新的线程，通过新的线程间接执行 run 中的代码

2. sleep和yield

   * 调用 sleep 会让当前线程从 *Running* 进入 *Timed Waiting* 状态（阻塞）
   * 其它线程可以使用 interrupt 方法打断正在睡眠的线程，这时 sleep 方法会抛出 InterruptedException
   * 睡眠结束后的线程未必会立刻得到执行
   * 建议用 TimeUnit 的 sleep 代替 Thread 的 sleep 来获得更好的可读性
   * 调用yield会让当前线程从Rurmning 进入Rurmable就绪状态，然后调度执行其它线程
   * yield具体的实现依赖于操作系统的任务调度器

3. sleep应用

   * 使用sleep让出cpu使用权，**sleep使用无需锁操作的同步场景**
   * 可以使用wait或条件变量达到类似效果，但此时需要加锁，并且需要相应的唤醒操作，**一般适用于要进行同步的场景**

4. join的同步应用

   ~~~java
   static int r1 = 0;
   static int r2 = 0;
   public static void main(String[] args) throws InterruptedException {
    test2();
   }
   private static void test2() throws InterruptedException {
    Thread t1 = new Thread(() -> {
    sleep(1);
    r1 = 10;
    });
    Thread t2 = new Thread(() -> {
    sleep(2);
    r2 = 20;
    });
    long start = System.currentTimeMillis();
    t1.start();
    t2.start();
    t1.join();
    t2.join();
    long end = System.currentTimeMillis();
    log.debug("r1: {} r2: {} cost: {}", r1, r2, end - start);
   }
   ~~~

   ![image-20230415185212974](https://whymechen.oss-cn-chengdu.aliyuncs.com/image/202304151852129.png)

5. interrupt

   * 打断 sleep，wait，join 的线程：这几个方法都会让线程进入阻塞状态打断 sleep 的线程, 会清空打断状态
   * 打断正常运行的线程：不会清空打断状态
   * 打断 park 线程：不会清空打断状态

### 主线程和守护线程

1. 主线程
   * 默认情况下，Java 进程需要等待所有线程都运行结束，才会结束。
2. 守护线程
   * 有一种特殊的线程叫做守护线程，只要其它非守护线程运行结束了，即使守护线程的代码没有执行完，也会强制结束。
   * 垃圾回收器线程就是一种守护线程
   * Tomcat中的Acceptor和Poller线程都是守护线程，所以Tomcat接收到shutdown命令后，不会等待
     它们处理完当前请求

### 线程状态

#### 状态描述

1. 五种状态说法

   从操作系统层面描述，

   * 【初始状态】仅是在语言层面创建了线程对象，还未与操作系统线程关联
   * 【可运行状态】（就绪状态）指该线程已经被创建（与操作系统线程关联），可以由 CPU 调度执行
   * 【运行状态】指获取了 CPU 时间片运行中的状态当 CPU 时间片用完，会从【运行状态】转换至【可运行状态】，会导致线程的上下文切换【阻塞状态】如果调用了阻塞 API，如 BIO 读写文件，这时该线程实际不会用到 CPU，会导致线程上下文切换，进入
   * 【阻塞状态】等 BIO 操作完毕，会由操作系统唤醒阻塞的线程，转换至【可运行状态】与【可运行状态】的区别是，对【阻塞状态】的线程来说只要它们一直不唤醒，调度器就一直不会考虑调度它们
   * 【终止状态】表示线程已经执行完毕，生命周期已经结束，不会再转换为其它状态

   ![image-20230415224305159](https://whymechen.oss-cn-chengdu.aliyuncs.com/image/202304152243741.png)

2. 六种状态说法

   从Java API层面描述，根据Thread.state枚举区分，

   * NEW 线程刚被创建，但是还没有调用 start() 方法
   * RUNNABLE 当调用了 start() 方法之后，注意，**Java API** 层面的 RUNNABLE 状态涵盖了 **操作系统** 层面的【可运行状态】、【运行状态】和【阻塞状态】（由于 BIO 导致的线程阻塞，在 Java 里无法区分，仍然认为是可运行）
   * BLOCKED ， WAITING ， TIMED_WAITING 都是 **Java API** 层面对【阻塞状态】的细分
   * TERMINATED 当线程代码运行结束

   ![image-20230415224951509](https://whymechen.oss-cn-chengdu.aliyuncs.com/image/202304152249884.png)

#### 状态转换

## 共享模型之管程

### 共享问题

1. 临界区：一段代码块内如果存在对**共享资源**的多线程读写操作，称这段代码块为**临界区**
2. 竞态条件：多个线程在临界区内执行，由于代码的**执行序列不同**而导致结果无法预测，称之为发生了**竞态条件**

### 解决方案

为了避免临界区的竞态条件发生，有多种手段可以达到目的。

* 阻塞式的解决方案：synchronized, Lock
* 非阻塞式的解决方案：原子变量

#### Synchronized（对象锁）

采用互斥的方式让同一时刻至多只有一个线程能持有【对象锁】，其它线程再想获取这个【对象锁】时就会阻塞住。这样就能保证拥有锁的线程可以安全的执行临界区内的代码，不用担心线程上下文切换。

1. 语法

   ~~~java
   synchronized(对象锁){
       //临界区
   }
   ~~~

2. 分析

   ![image-20230415232702746](https://whymechen.oss-cn-chengdu.aliyuncs.com/image/202304152327435.png)

3. 理解

   > synchronized实际是用对象锁保证了临界区内代码的原子性，临界区内的代码对外是不可分割的，不会被线程切换所打断。
   >
   > * 如果把 synchronized(obj) 放在 for 循环的外面，如何理解？-- 原子性
   > * 如果 t1 synchronized(obj1) 而 t2 synchronized(obj2) 会怎样运作？-- 锁对象
   > * 如果 t1 synchronized(obj) 而 t2 没有加会怎么样？如何理解？-- 锁对象

4. 方法上的synchronized

   ~~~java
   //成员方法上
   class Test{
    public synchronized void test() {
    
    }
   }
   //等价于
   class Test{
    public void test() {
    synchronized(this) {
    
    }
    }
   }
   ~~~

   ~~~java
   //静态方法上
   class Test{
    public synchronized static void test() {
    }
   }
   等价于
   class Test{
    public static void test() {
    synchronized(Test.class) {
    
    }
    }
   }
   ~~~

5. “线程八锁”案例分析

#### Monitor

### wait/notify

### 活跃性

### Lock

## 线程安全

### 变量的线程安全分析

1. 成员变量和静态变量
   * 如果它们没有共享，则线程安全
   * 如果它们被共享了，根据它们的状态是否能够改变，分两种情况
     * 如果只有读操作，则线程安全
     * 如果有读写操作，则这段代码是临界区，需要考虑线程安全
2. 局部变量
   * 局部变量是线程安全的
   * 局部变量引用的对象则未必
     * 如果该对象没有逃离方法的作用访问，它是线程安全的
     * 如果该对象逃离方法的作用范围，需要考虑线程安全

## 线程池

## 多线程设计

### 两阶段终止模式（Two Phase Termination）

1. 在一一个线程T1中如何“优雅“终止线程T2?

   * interrupt分析

     ![image-20230415222713338](https://whymechen.oss-cn-chengdu.aliyuncs.com/image/202304152227204.png)

   * interrupt实现

     ![image-20230415223429778](https://whymechen.oss-cn-chengdu.aliyuncs.com/image/202304152234907.png)

## 线程安全类

常见的线程安全类：

* String
* StringBuffer
* Integer
* Random
* Vector
* Hashtable
* java.util.concurrent包下的类

> 注意：
>
> 此处线程安全的是指多个线程调用它们同一个实例的某个方法时，是线程安全的。也可以理解为：
>
> * 它们的每个方法是原子的
> * 但它们多个方法的组合不是原子的

### 不可变类线程安全分析

String、Integer 等都是不可变类，因为其内部的状态不可以改变，因此它们的方法都是线程安全的。

### 集合相关

## 异步技巧

### CompletableFuture 

参考：

* [从 5s 到 0.5s！看看人家的 CompletableFuture 异步任务优化技巧，确实优雅！](https://mp.weixin.qq.com/s/L5RLrWTzEr_qVXoMQuYedg)
* [快速学会 CompletableFuture 使用，异步编排神器！ (qq.com)](https://mp.weixin.qq.com/s/UFMVaGS_nod2sfEayEzrMA)

## 参考资料

视频：

文章：

* [从 5s 到 0.5s！看看人家的 CompletableFuture 异步任务优化技巧，确实优雅！](https://mp.weixin.qq.com/s/L5RLrWTzEr_qVXoMQuYedg)
* [Java并发知识体系详解](https://pdai.tech/md/java/thread/java-thread-x-overview.html#java%E5%B9%B6%E5%8F%91%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E8%AF%A6%E8%A7%A3)
