# Java SE

## 基础

1. 重载和重写的区别？

2. ==与equals的比较？

3. equals（）和hashCode（）的理解

   > 两个均为Object类中的方法，对于相同的对象hash值必然相等。有强制的规范指定需要同时重写 hashcode 与 equals 方法

4. 谈谈final关键字。

   > 可以作用在类、成员变量和成员方法上，表示类不能被继承，方法不能被重写，变量初始化后不能被修改

5. 说说final、finalize、finally的区别

   > 

6. 

7. String、StringBuffer和StringBuilder的区别？String为什么是不可变的？

   > String由于底层是一个字节数组，适应final修饰，所以是不可变和线程安全的。StringBuffer和StringBuilder均可变，但是StringBuffer是线程安全的，StringBuilder是线程不安全的。

8. 简单说一说java 的异常处理机制。

9. 键盘输入的常用方法。

10. 能在Swith中使用String吗

    > 从 Java 7 开始，我们可以在 switch case 中使用字符串，但这仅仅是一个语法糖。内部实现在 switch 中使用字符串的 hash code。

## 面向对象

1. 面向对象的三大特性？

   > * 封装
   > * 继承
   > * 多态

2. Object类中的常用方法

   > 线程相关
   >
   > - notify() //唤醒在此对象监视器上等待的单个线程。
   > - notifyAll() //唤醒在此对象监视器上等待的所有线程。
   > - wait() //用于让当前线程失去操作权限，当前线程进入等待序列
   >
   > ---
   >
   > 对象相关
   >
   > - clone() //创建并返回此对象的一个副本。
   > - equals(Object obj) //用于确认两个对象是否“相同”。
   > - toString() //返回该对象的字符串表示。
   > - hashCode() //用于获取对象的哈希值。
   >
   > ---
   >
   > 其他
   >
   > - finalize() //由对象的垃圾回收器调用此方法。
   > - getClass() //返回此 Object 的运行类。

3. 接口

## 接口和抽象类

1. 接口和抽象类的区别。

   > 接口使用interfere修饰，抽象类使用abstract修且抽象类不能使用final关键字修饰；
   >
   > 一个类只能继承一个抽象类，而可以实现多个接口；
   >
   > 抽象类可以有构造方法，接口没有；
   >
   > 抽象类的方法没有权限限制，但接口只能使用public修饰

## 异常

## 泛型

1. 为什么需要泛型

   > 主要是为了解决ClassCastException异常，类在向下转型时可能存在安全隐患

## 反射

1. 生成Class字节码文件的方式

   > * Object的（类对象）getClass方法
   > * 类名.class获得
   > * Class.forName()方法

2. 看

## 集合

### ArrayList

1. ArrayList的扩容机制

   > 使用无参构造初始化，初始容量为0；使用有参构造创建并指定初始容量大小则初始容量为指定值；使用数组初始化为数组大小。
   >
   > 当使用add方法添加元素时，则初次扩容为10，之后按照原容量的1.5倍进行扩容。当使用AddAll方法扩容，无元素时，扩容为Max（10，实际元素个数），有元素时，扩容为Max（原容量的1.5倍，实际元素个数）

2. iterator的fail-fast和fail-safe机制

   > faile-fast不允许边遍历边修改，否则会抛出异常，典型的就是ArrayList。fail-safe允许边遍历边修改，典型的是CopyOnWriteArrayList。

3. ArrayList和LinkedList的区别

### HashMap

1. HashMap的底层数据结构，在jdk1.7和1.8中有什么不同

   > 1.7中使用数组和链表的组合形式，1.8中使用数组和链表或者红黑树的形式

2. 为什么HashMap的底层数据结构在jdk1.8中会使用红黑树，什么时候树化，什么时候退化为链表，为什么将链表转化为红黑树的阈值是8，为什么不一上来就直接使用红黑树，

   > 当链表长度大于8且数组长度大于64是会尝试树化。
   >
   > 因为在元素个数少时，链表的效率在一定程度上优于红黑树，反而如果一上来就使用红黑树，反而需要维护红黑树，造成效率的降低。

3. 索引如何计算? hashCode都有了，为何还要提供hash()方法?数组容量为何是2的n次幂?

4. jdk1.7和1.8中put方法有何区别

## 多线程

1. 为什么需要多线程。
2. 什么是线程安全。

# Javaweb

## HTTP协议

1. get和post方式的区别

   > * get参数拼接在url中，post的参数在方法体中且只有post范式才有方法体。
   > * get方式一般传输数据大小有限制，post理论上没有限制
   > * get请求可以缓存，post请求不可以缓存
   > * get请求后退无影响，post请求后退会重新提交请求

2. 转发和重定向的区别

   > * 转发地址栏无变化，重定向地址栏有变化
   > * 转发请求次数为1，可以使用request域对象共享数据，重定向请求次数为2，不可以使用request域对象共享数据
   > * 转发是服务器行为，只能访问当前服务器资源，重定向是客户端行为，可以访问其他服务器资源

3. 空间

## Servlet

## JSP

1. jsp的九个内置对象及其作用

   > pageContext：表示页容器，EL表达式、标签
   >
   > seesion：用于一次会话的多个请求间共享数据，常用于登录验证
   >
   > request：用于获取客户端信息，包括头信息、cookie和请求参数等
   >
   > response：服务器端响应客户端信息，cookie、重定向
   >
   > application：表示整个服务器，可用于多个web项目间的数据共享
   >
   > page：相当于this对象，表示整个jsp页面自身
   >
   > out：输出
   >
   > config：获得初始化参数，初始化参数在web.xml文件中配置
   >
   > exception：表示错误也的处理操作

2. 说一说jsp的六种标签

   > 指令标签、声明标签、表达式标签、代码标签、注释标签、动作标签

3. 说以说jsp的四大域对象

   > 均用于数据的存储，不同之处在于存取范围不同。从小到大依次为pageContext、request、session、application

4. 静态包含和动态包含的区别

   > 静态包含的代码为：
   >
   > `<%@ include file="/include/include2.jsp"%>`
   >
   > 动态包含的代码为：
   >
   > `<jsp:include page="/include/include2.jsp"></jsp:include>`
   >
   > 静态包含不可以传递参数，而动态包含可以。静态包含适用于没有大量java代码的jsp，而动态包含适用于需要传递参数且包含大量java代码的jsp

5. 看来

## Cookie和Session

## Filter和Listener

# 框架

## Spring

1. 什么是Spring。

2. 什么是IOC，IOC的实现原理

   > IOC的实现原理是反射+工厂模式

3. 列举一些常用的Spring模块。

4. Spring中bean的作用域有哪些

   > singleton、prototype、request、session、global

5. 谈一谈Spring MVC的了解。

6. 什么是AOP，有哪些概念。

   > AOP，面向切面编程，主要的作用是在对原代码无侵入的情况下对原代码的功能进行增强。Spring AOP是基于动态代理实现的。
   >
   > 重要概念有连接点、切入点、通知、切面

7. Spring AOP中通知的类型有哪几种

   > 前置通知、后置通知、环绕通知、返回后通知、异常通知。

8. AOP有哪些应用场景

   > 记录日志(调用方法后记录日志)
   >
   > 监控性能(统计方法运行时间)
   >
   > 权限控制(调用方法前校验是否有权限)
   >
   > 事务管理(调用方法前开启事务，调用方法后提交关闭事务 )
   >
   > 缓存优化(第一次调用查询数据库，将查询结果放入内存对象， 第二次调用，直接从内存对象返回，不需要查询数据库 )

9. Spring事务的隔离级别

   > 在TransactionDefinition接口中定义了五个表示隔离级别的常量：
   >
   > ISOLATION_DEFAULT：使用后端数据库默认的隔离级别，Mysql默认采用的REPEATABLE_READ隔离级别；Oracle默认采用的READ_COMMITTED隔离级别。
   >
   > ISOLATION_READ_UNCOMMITTED：最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读。
   >
   > ISOLATION_READ_COMMITTED：允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生
   >
   > ISOLATION_REPEATABLE_READ：对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。
   >
   > ISOLATION_SERIALIZABLE：最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。但是这将严重影响程序的性能。通常情况下也不会用到该级别。

10. Spring事务的传播行为有几种

    > ![image-20230217115402849](https://whymechen.oss-cn-chengdu.aliyuncs.com/image/202302171154816.png)

## SpringBoot

## Mybatis

# MySQL

# Redis

1. 

# 微服务

# 并发

# 虚拟机

# Linux

# 数据结构

## 排序与查找

### 二分查找

1. 基本原理及复杂度分析

2. 基本代码

   ~~~java
       /**
        * @param arr 已有序的数组
        * @param t   待查找元素
        * @return
        */
       public static int binarySearch(int[] arr, int t) {
           //左边界
           int l = 0;
           //右边界
           int r = arr.length - 1;
           //中间索引
           int m;
           while (l <= r) {
               m = (l + r) / 2;
               if (t == arr[m]) {
                   return m;
               } else if (t > arr[m]) {
                   l = m + 1;
               } else {
                   r = m - 1;
               }
           }
           //未找到
           return -1;
       }
   ~~~

   * 中间索引溢出问题
     * 解决
       * 方式一：m=l+(r-l)/2
       * 方式二：(l+r)>>>1

3. 相关面试题

   ![image-20220909135456821](https://whymechen.oss-cn-chengdu.aliyuncs.com/image/202302151648021.png)

   * 技巧：奇数二分取中间，偶数二分取中间靠左

### 冒泡排序

1. 思路

2. 实现

   ```java
   /**
    * 冒泡排序基本实现
    * @param arr 待排序数组
    */
   public static void bubbleSort(int[] arr) {
       //记录元素是否发生交换
       boolean swapped =false;
       for (int i = 0; i < arr.length - 1; i++) {
           swapped = false;
           for (int j = 0; j < arr.length - 1 - i; j++) {
               if (arr[j] > arr[j + 1]) {
                   swap(arr, j, j + 1);
                   swapped = true;
               }
           }
           System.out.println("第"+(i+1)+"轮冒泡："+Arrays.toString(arr));
           //已经有序
           if (!swapped){
               break;
           }
       }
   }
   
   /**
    * 冒泡排序优化
    * 优化思路：每轮冒泡时，最后一次交换
    *  索引可以作为下一-轮冒泡的比较次数,
    *  如果这个值为零，表示整个数组有序,
    *  直接退出外层循环即可
    * @param arr 待排序数组
    */
   public static void bubbleSort2(int[] arr) {
       int n= arr.length-1;
       while (true){
           //表示最后一次交换的索引位置
           int last=0;
           for (int i = 0; i < n; i++) {
               if (arr[i]>arr[i+1]){
                   swap(arr,i,i+1);
                   last=i;
               }
           }
           n=last;
           if (n==0){
               break;
           }
       }
   }
   ```

### 选择排序

1. 思路：

   > 将数组分为两个子集，排序的和未排序的，每一轮从未排序的子集中选出最小的元素,放入已排序子集。重复以上步骤，直到整个数组有序

2. 实现

   ```java
   public static void selectSort(int[] arr){
       int min=0;
       for (int i = 0; i < arr.length - 1; i++) {
           for (int j = i+1; j < arr.length; j++) {
               if (arr[min]>arr[j]){
                   min=j;
               }
           }
           swap(arr,min,i);
       }
   }
   ```

### 插入排序

1. 思路

   > 将数组分为两个区域,排序区域和未排序区域,每一轮从未排序区域中取出第一个元素，插入到排序区域(需保证顺序)

2. 实现

   ```java
   public static void insertSort(int[] arr){
       for (int i = 1; i < arr.length; i++) {
           int temp = arr[i];
           int j;
           for (j = i-1; j >= 0 ; j--) {
               if (temp<arr[j]){
                   arr[j+1]=arr[j];
               }else {
                   break;
               }
           }
           arr[j+1]=temp;
       }
   }
   ```

# 设计模式

## 单例模式

# 前端

## HTML+CSS

## JavaScript

## Vue

# 非技术类

大学生IQT思维能力测评：https://www.bilibili.com/video/BV1eN4y1c77w/?spm_id_from=333.788.recommend_more_video.-1&vd_source=fabefd3fabfadb9324761989b55c26ea

全新逻辑系统课—论证推理：https://www.bilibili.com/video/BV1KW411S7ea/?spm_id_from=333.337.search-card.all.click&vd_source=fabefd3fabfadb9324761989b55c26ea

## 逻辑推理

> 包括图形推理、定义判断、逻辑判断、类比推理

## 数学判断

> 主要为数学运算

## 言语理解

> 包括言语理解、逻辑填空、阅读理解、语句表达

## 材料分析

> 包括简单计算、基期与现期、增长率、增长量、比重问题、平均数问题、



