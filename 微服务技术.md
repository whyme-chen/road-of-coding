# 微服务技术

## 微服务简介

### 微服务技术栈

1. 服务网关
2. 注册中心
3. 配置中心
4. 服务集群
5. 分布式缓存
6. 分布式搜索
7. 分布式日志框架
8. 统一部署平台

![image-20220616221642790](https://whymechen.oss-cn-chengdu.aliyuncs.com/image/202206162216086.png)

![image-20220616221927980](https://whymechen.oss-cn-chengdu.aliyuncs.com/image/202206162257980.png)

![image-20220616222141070](https://whymechen.oss-cn-chengdu.aliyuncs.com/image/202206162258405.png)

![image-20230311183945358](https://whymechen.oss-cn-chengdu.aliyuncs.com/image/202303111839545.png)

### 微服务架构演变

1. 单体架构：将业务所有功能集中在一个项目中开发，生成一个包进行部署

   * 优点：架构简单、部署成本低
   * 缺点：耦合度高

2. 分布式架构：根据业务功能对系统拆分，每个业务模块作为一个独立项目开发，称为一个服务

   * 优点：降低服务耦合度，有利于服务升级扩展
   * 服务治理（分布式架构的要考虑的问题）
     * 服务拆分粒度如何?
     * 服务集群地址如何维护?
     * 服务之间如何实现远程调用?
     * 服务健康状态如何感知?

3. 微服务：**微服务是一种经过良好架构设计的分布式架构方案**

   * 微服务架构特征:

     * 单一职责:微服务拆分粒度更小，每-一个服务都对应唯一的业务能力，做到单一职责,避免重复业务开发
     * 面向服务：微服务对外暴露业务接口
     * 自治：团队独立、技术独立、数据独立、部署独立
     * 隔离性强：服务调用做好隔离、容错、降级,避免出现级联问题

   * 结构：在国内最知名的微服务技术框架就是SpringCloud和阿里巴巴Dubbo。

   * 技术对比

     ![image-20220616225122343](https://whymechen.oss-cn-chengdu.aliyuncs.com/image/202206162258252.png)

## Spring Cloud

1. 简介

2. 版本兼容性

   ![image-20220616225638824](https://whymechen.oss-cn-chengdu.aliyuncs.com/image/202206181721335.png)

### 服务拆分及远程调用

1. 服务拆分注意事项：

   * 不同微服务，不重复开发相同业务
   * 微服务数据独立，不访问其他微服务的数据库
   * 微服务可以将自己的业务暴露为接口，供其他服务使用

2. 服务远程调用

   > 1. 注册RestTemplate
   >
   >    ![image-20220617224745750](https://whymechen.oss-cn-chengdu.aliyuncs.com/image/202206181721514.png)
   >
   > 2. 服务远程调用RestTemplate
   >
   >    ![image-20220617225833140](https://whymechen.oss-cn-chengdu.aliyuncs.com/image/202206181721414.png)

3. 提供者与消费者

   * 服务提供者与消费者是相对的

### EureKa注册中心

1. 服务调用中的问题

   * 服务消费者该如何获取服务提供者的地址信息?
   * 如果有多个服务提供者,消费者该如何选择?
   * 消费者如何得知服务提供者的健康状态? 

2. eureka的作用

   * EurekaServer：服务端，注册中心
     * 记录服务信息
     * 心跳监控
   * EruekaClient：客户端
     * Provider：服务提供者，将自身信息注册到注册中心，每隔30秒向注册中心发送心跳
     * consumer：服务消费者，根据服务名称从注册中心拉取服务列表，基于服务列表做负载均衡，选中一个微服务后发起远程调用

   ![image-20220618171448837](https://whymechen.oss-cn-chengdu.aliyuncs.com/image/202206181721711.png)

3. 动手实践

   * 搭建注册中心

     ![image-20220618172353099](https://whymechen.oss-cn-chengdu.aliyuncs.com/image/202206181723946.png)

   * 服务注册

     ![image-20220618175957800](https://whymechen.oss-cn-chengdu.aliyuncs.com/image/202206181800933.png)

     模拟多实例部署：

     ![image-20220618215953095](https://whymechen.oss-cn-chengdu.aliyuncs.com/image/202206182200358.png)

   * 服务发现

     ![image-20220618220255386](https://whymechen.oss-cn-chengdu.aliyuncs.com/image/202206182202134.png)

   总结：

   ![image-20220618235120394](C:\Users\hp\AppData\Roaming\Typora\typora-user-images\image-20220618235120394.png)

### Ribbon负载均衡

1. 负载均衡流程

   ![image-20220619111019572](C:\Users\hp\AppData\Roaming\Typora\typora-user-images\image-20220619111019572.png)

   ![image-20220619111733756](https://whymechen.oss-cn-chengdu.aliyuncs.com/image/202206191119756.png)

2. 负载均衡策略

   ![image-20220619111906061](https://whymechen.oss-cn-chengdu.aliyuncs.com/image/202206191124670.png)

   ![image-20220619111926430](https://whymechen.oss-cn-chengdu.aliyuncs.com/image/202206191124252.png)

   ![image-20220619112416337](https://whymechen.oss-cn-chengdu.aliyuncs.com/image/202206191124665.png)

3. 饥饿加载

   ![image-20220619113011093](https://whymechen.oss-cn-chengdu.aliyuncs.com/image/202206191130698.png)

### Nacos注册中心

1. 安装nacos

   * 下载：在Nacos的GitHub页面，提供有下载链接，可以下载编译好的Nacos服务端或者源代码：
     * GitHub主页：https://github.com/alibaba/nacos
     * GitHub的Release下载页：https://github.com/alibaba/nacos/releases
   * 配置：Nacos的默认端口是8848，若电脑上的其它进程占用了8848端口，请先尝试关闭该进程。**如果无法关闭占用8848端口的进程**，也可以进入nacos的conf目录中的配置文件application.properties修改的端口。
   * 启动
     * 双击bin目录中的startup.cmd
     * 执行命令startup.cmd -m standalone
   * 访问：在浏览器输入地址：http://127.0.0.1:8848/nacos即可，登录默认的账号和密码都是nacos进入。

2. nacos的依赖

   父工程：

   ```xml
   <dependency>
       <groupId>com.alibaba.cloud</groupId>
       <artifactId>spring-cloud-alibaba-dependencies</artifactId>
       <version>2.2.5.RELEASE</version>
       <type>pom</type>
       <scope>import</scope>
   </dependency>
   ```

   客户端：

   ```xml
   <!-- nacos客户端依赖包 -->
   <dependency>
       <groupId>com.alibaba.cloud</groupId>
       <artifactId>spring-cloud-starter-alibaba-nacos-discovery</artifactId>
   </dependency>
   ```

3. 动手实践

   ![image-20220621222022415](https://whymechen.oss-cn-chengdu.aliyuncs.com/image/202206232155659.png)

   ![image-20220621222249577](https://whymechen.oss-cn-chengdu.aliyuncs.com/image/202206232155264.png)

4. nacos服务分级存储模型

   * 分级存储模型
     * 一级是服务
     * 二级是集群
     * 三级是实例

   ![image-20220623215211993](https://whymechen.oss-cn-chengdu.aliyuncs.com/image/202206232155127.png)

   * 服务跨集群调用的问题

     * 服务调用尽可能选择本地集群服务，跨集群调用延迟较高。只有本地集群不可访问时，再去访问其他集群。

   * 配置服务集群属性

     ![image-20220623215446583](https://whymechen.oss-cn-chengdu.aliyuncs.com/image/202206232155960.png)

   * 根据集群负载均衡

     ![image-20220623222043416](C:\Users\hp\AppData\Roaming\Typora\typora-user-images\image-20220623222043416.png)

   * 根据权重负载均衡

     * 实际部署场景：
       * 服务器设备性能存在差异，部分实例所在机器性能较好，另一些较差，我们希望性能好的机器承担更多的用户请求

   * 空间

5. 接口

## RabbitMQ

### MQ基本概念

1. MQ：全称Message Queue (消息队列)，是在消息的传输过程中保存消息的容器。多用于分布式系统之间进行通信。

2. 优势

   * 应用解耦

   * 削峰填谷

   * 异步提速

     ![image-20230313225333941](https://whymechen.oss-cn-chengdu.aliyuncs.com/image/202303132253511.png)

3. 劣势

   * 系统可用性降低
   * 系统复杂性提高
   * 一致性问题

4. MQ应用条件

   * 生产者不需要从消费者处获得反馈
   * 容许短暂的不一致性

5. 常见的MQ产品

   * RabbitMQ
   * RocketMQ
   *  ActiveMQ
   * Kafka
   *  ZeroMQ
   * MetaMq

   ![image-20230313230133285](https://whymechen.oss-cn-chengdu.aliyuncs.com/image/202303132301585.png)

6. AMQP：AMQP，即Advanced Message Queuing Protocol (高级消息队列协议) ,是一个网络协议，是应用层协议的一个开放标准，为面向消息的中间件设计。基于此协议的客户端与消息中间件可传递消息，并不受客户端/中间件不同产品，不同的开发语言等条件的限制。2006年， AMQP规范发布。类比HJTP。

### RabbitMQ简介

![image-20230313232906539](https://whymechen.oss-cn-chengdu.aliyuncs.com/image/202303132329639.png)

![image-20230313232947012](https://whymechen.oss-cn-chengdu.aliyuncs.com/image/202303132329894.png)

![image-20230313233040344](https://whymechen.oss-cn-chengdu.aliyuncs.com/image/202303132330009.png)

![image-20230313233121119](https://whymechen.oss-cn-chengdu.aliyuncs.com/image/202303132331854.png)

### 快速使用

官网：https://www.rabbitmq.com/

1. 下载安装

   > docker安装：https://blog.csdn.net/weixin_44666439/article/details/127265712?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-0-127265712-blog-124470698.235^v27^pc_relevant_3mothn_strategy_recovery&spm=1001.2101.3001.4242.1&utm_relevant_index=3

2. 入门使用：使用简单模式完成消息传递

   * 创建工程（生产者、消费者）
   * 分别添加依赖
   * 编写生产者发送消息
   * 编写消费者接收消息

   ~~~java
   package org.example.producer;
   
   import com.rabbitmq.client.AMQP;
   import com.rabbitmq.client.Channel;
   import com.rabbitmq.client.Connection;
   import com.rabbitmq.client.ConnectionFactory;
   
   import java.io.IOException;
   import java.nio.charset.StandardCharsets;
   import java.util.concurrent.TimeoutException;
   
   /**
    * 生产者
    * @Author chen
    * @Date 2023/3/25
    * @Version 1.0
    **/
   public class ProducerDemo1 {
       public static void main(String[] args) throws IOException, TimeoutException {
           //创建连接工厂
           ConnectionFactory connectionFactory = new ConnectionFactory();
           //设置参数
           connectionFactory.setHost("47.120.2.57");
           connectionFactory.setPort(5672);
           connectionFactory.setVirtualHost("demo");
           connectionFactory.setUsername("admin");
           connectionFactory.setPassword("admin");
           //创建连接
           Connection connection = connectionFactory.newConnection();
           //创建Channel
           Channel channel = connection.createChannel();
           //创建队列Quene
           AMQP.Queue.DeclareOk declareOk = channel.queueDeclare("hello",true,false,false,null);
           //发送消息
           String body = "hello rabbitmq!";
           channel.basicPublish("","hello",null,body.getBytes(StandardCharsets.UTF_8));
   
           channel.close();
           connection.close();
       }
   }
   
   ~~~

   ~~~java
   package org.example.consumer;
   
   import com.rabbitmq.client.*;
   
   import java.io.IOException;
   import java.nio.charset.StandardCharsets;
   import java.util.concurrent.TimeoutException;
   
   /**
    * 消费者
    * @Author chen
    * @Date 2023/3/25
    * @Version 1.0
    **/
   public class ConsumerDemo1 {
       public static void main(String[] args) throws IOException, TimeoutException {
           //创建连接工厂
           ConnectionFactory connectionFactory = new ConnectionFactory();
           //设置参数
           connectionFactory.setHost("47.120.2.57");
           connectionFactory.setPort(5672);
           connectionFactory.setVirtualHost("demo");
           connectionFactory.setUsername("admin");
           connectionFactory.setPassword("admin");
           //创建连接
           Connection connection = connectionFactory.newConnection();
           //创建Channel
           Channel channel = connection.createChannel();
           //创建队列Quene
           AMQP.Queue.DeclareOk declareOk = channel.queueDeclare("hello",true,false,false,null);
           //消费消息
           Consumer consumer = new DefaultConsumer(channel){
               /**
                * 这是一个回调方法，当收到消息后会自动执行该方法
                * @param consumerTag 标识
                * @param envelope 获取信息，包括：交换机、路由key
                * @param properties 配置信息
                * @param body 数据
                * @throws IOException
                */
               @Override
               public void handleDelivery(String consumerTag,
                                          Envelope envelope,
                                          AMQP.BasicProperties properties,
                                          byte[] body) throws IOException {
                   System.out.println("consumerTag:"+consumerTag);
                   System.out.println("envelope:"+envelope.getExchange());
                   System.out.println("envelope:"+envelope.getRoutingKey());
                   System.out.println("properties:"+properties);
                   System.out.println("body:"+new String(body));
               }
           };
           channel.basicConsume("hello",true,consumer);
   
       }
   }
   
   ~~~

## Docker

学习视频：https://www.bilibili.com/video/BV1CJ411T7BK?p=1

### 简介

1. 容器：

   * **解决软件跨环境迁移问题**
   * 完全使用沙箱机制，相互隔离
   * 性能开销极低

2. Docker：一个开源的应用容器引擎

   * 官网：https://www.docker.com
   * 诞生于2013年初,基于Go语言实现，dotCloud 公司出品(后改名为Docker Inc)
   * Docker可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的Linux机器上。
   * Docker从17.03版本之后分为CE (Community Edition:社区版)和EE (Enterprise Edition:企业版)

3. docker架构

   ![image-20230311195708638](https://whymechen.oss-cn-chengdu.aliyuncs.com/image/202303111957973.png)

4. 配置镜像加速器

   阿里云：https://cr.console.aliyun.com/cn-heyuan/instances/mirrors

5. docker容器虚拟化和传统虚拟机虚拟化的比较

   ![image-20230311230728514](https://whymechen.oss-cn-chengdu.aliyuncs.com/image/202303112307226.png)

### 常用命令

1. 服务相关

   > 启动docker服务：system start docker
   >
   > 停止docker服务：system stop docker
   >
   > 重启docker服务：system restart docker
   >
   > 查看docker服务状态：system status docker
   >
   > 开机启动docker服务：system enable docker

2. 镜像相关命令

   镜像地址：https://hub.docker.com/

   > 查看镜像：docker images
   >
   > 搜索镜像：docker search
   >
   > 拉取镜像：docker pull
   >
   > 删除镜像：docker rmi

3. 容器相关命令

   > 查看正在运行的容器：docker ps
   >
   > ​	-a：表示查看所有容器
   >
   > 创建容器：docker run 
   >
   > ​	-i：保持容器运行。通常与-t同时使用。加入it这两个参数后,容器创建后自动进入容器中，退出容器后，容器自动关闭。
   >
   > ​	-t: 为容器重新分配一个伪输入终端，通常与-i同时使用。
   > ​	-d:以守护(后台)模式运行容器。创建一个容器在后台运行， 需要使用dockerexec进入容器。退出后，容器不会关闭。
   > ​	-it创建的容器-般称为交互式容器， -id 创建的容器一般称为守护式容器
   > ​	--name:为创建的容器命名。
   >
   > 进入容器：docker exec
   > 启动容器：docker start
   > 停止容器：docker stop
   > 删除容器：docker rm
   > 查看容器信息：docker inspect

### 容器数据卷

1. 数据卷：数据卷是宿主机中的一个目录或文件

   * 当容器目录和数据卷目录绑定后，对方的修改会立即同步
   * 一个数据卷可以被多个容器同时挂载
   * -个容器也可以被挂载多个数据卷

2. 作用

   * 容器数据持久化
   * 外部机器和容器间接通信
   * 容器之间数据交换

3. 配置数据卷

   > docker run ... -v 宿主机目录(文件) :容器内目录(文件)
   >
   > 注意事项：
   >
   > * 目录必须是绝对路径
   > * 如果目录不存在,会自动创建
   > * 可以挂载多个数据卷

4. 数据卷容器

   ![image-20230311213730377](https://whymechen.oss-cn-chengdu.aliyuncs.com/image/202303112137385.png)

### 应用部署

### Dockerfile

1. docker镜像原理

   ![image-20230311215746393](https://whymechen.oss-cn-chengdu.aliyuncs.com/image/202303112157213.png)

2. docker镜像制作（基于容器制作）

   ![image-20230311220359398](https://whymechen.oss-cn-chengdu.aliyuncs.com/image/202303112204252.png)

#### Dockerfile

1. 简介

   * Dockerfile是一个文本文件
   * 包含了-条条的指令，每一条指令构建-层,基于基础镜像，最终构建出一一个新的镜像
   * 对于开发人员:可以为开发团队提供一个完全一致的开发环境
   * 对于测试人员:可以直接拿开发时所构建的镜像或者通过Dockerfile文件构建一个新的镜像开始工作
   * 对于运维人员:在部署时，可以实现应用的无缝移植

2. 常见关键字

   | 关键字      | 作用                     | 备注                                                         |
   | ----------- | ------------------------ | ------------------------------------------------------------ |
   | FROM        | 指定父镜像               | 指定dockerfile基于那个image构建                              |
   | MAINTAINER  | 作者信息                 | 用来标明这个dockerfile谁写的                                 |
   | LABEL       | 标签                     | 用来标明dockerfile的标签 可以使用Label代替Maintainer 最终都是在docker image基本信息中可以查看 |
   | RUN         | 执行命令                 | 执行一段命令 默认是/bin/sh 格式: RUN command 或者 RUN ["command" , "param1","param2"] |
   | CMD         | 容器启动命令             | 提供启动容器时候的默认命令 和ENTRYPOINT配合使用.格式 CMD command param1 param2 或者 CMD ["command" , "param1","param2"] |
   | ENTRYPOINT  | 入口                     | 一般在制作一些执行就关闭的容器中会使用                       |
   | COPY        | 复制文件                 | build的时候复制文件到image中                                 |
   | ADD         | 添加文件                 | build的时候添加文件到image中 不仅仅局限于当前build上下文 可以来源于远程服务 |
   | ENV         | 环境变量                 | 指定build时候的环境变量 可以在启动的容器的时候 通过-e覆盖 格式ENV name=value |
   | ARG         | 构建参数                 | 构建参数 只在构建的时候使用的参数 如果有ENV 那么ENV的相同名字的值始终覆盖arg的参数 |
   | VOLUME      | 定义外部可以挂载的数据卷 | 指定build的image那些目录可以启动的时候挂载到文件系统中 启动容器的时候使用 -v 绑定 格式 VOLUME ["目录"] |
   | EXPOSE      | 暴露端口                 | 定义容器运行的时候监听的端口 启动容器的使用-p来绑定暴露端口 格式: EXPOSE 8080 或者 EXPOSE 8080/udp |
   | WORKDIR     | 工作目录                 | 指定容器内部的工作目录 如果没有创建则自动创建 如果指定/ 使用的是绝对地址 如果不是/开头那么是在上一条workdir的路径的相对路径 |
   | USER        | 指定执行用户             | 指定build或者启动的时候 用户 在RUN CMD ENTRYPONT执行的时候的用户 |
   | HEALTHCHECK | 健康检查                 | 指定监测当前容器的健康监测的命令 基本上没用 因为很多时候 应用本身有健康监测机制 |
   | ONBUILD     | 触发器                   | 当存在ONBUILD关键字的镜像作为基础镜像的时候 当执行FROM完成之后 会执行 ONBUILD的命令 但是不影响当前镜像 用处也不怎么大 |
   | STOPSIGNAL  | 发送信号量到宿主机       | 该STOPSIGNAL指令设置将发送到容器的系统调用信号以退出。       |
   | SHELL       | 指定执行脚本的shell      | 指定RUN CMD ENTRYPOINT 执行命令的时候 使用的shell            |

### Docker Compose

![image-20230311230230122](https://whymechen.oss-cn-chengdu.aliyuncs.com/image/202303112302382.png)

### Docker 私有仓库

# RPC

参考：https://www.bilibili.com/video/BV11i4y1N7LQ/?spm_id_from=333.337.search-card.all.click&vd_source=fabefd3fabfadb9324761989b55c26ea