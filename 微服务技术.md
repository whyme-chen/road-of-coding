# 	微服务技术

## 微服务简介

### 微服务技术栈

1. 服务网关
2. 注册中心
3. 配置中心
4. 服务集群
5. 分布式缓存
6. 分布式搜索
7. 分布式日志框架
8. 统一部署平台

![image-20220616221642790](https://whymechen.oss-cn-chengdu.aliyuncs.com/image/202206162216086.png)

![image-20220616221927980](https://whymechen.oss-cn-chengdu.aliyuncs.com/image/202206162257980.png)

![image-20220616222141070](https://whymechen.oss-cn-chengdu.aliyuncs.com/image/202206162258405.png)

学习课程：[SpringCloud+RabbitMQ+Docker+Redis+搜索+分布式，系统详解springcloud微服务技术栈课程|黑马程序员Java微服务](https://www.bilibili.com/video/BV1LQ4y127n4/?p=1&vd_source=fabefd3fabfadb9324761989b55c26ea)

![image-20230311183945358](https://whymechen.oss-cn-chengdu.aliyuncs.com/image/202303111839545.png)

### 微服务架构演变

1. 单体架构：将业务所有功能集中在一个项目中开发，生成一个包进行部署

   * 优点：架构简单、部署成本低
   * 缺点：耦合度高

2. 分布式架构：根据业务功能对系统拆分，每个业务模块作为一个独立项目开发，称为一个服务。

   * 优点：降低服务耦合度，有利于服务升级扩展
   * 服务治理（分布式架构的要考虑的问题）
     * 服务拆分粒度如何?
     * 服务集群地址如何维护?
     * 服务之间如何实现远程调用?
     * 服务健康状态如何感知?

3. 微服务：**微服务是一种经过良好架构设计的分布式架构方案**

   * 微服务架构特征:

     * 单一职责:微服务拆分粒度更小，每-一个服务都对应唯一的业务能力，做到单一职责,避免重复业务开发
     * 面向服务：微服务对外暴露业务接口
     * 自治：团队独立、技术独立、数据独立、部署独立
     * 隔离性强：服务调用做好隔离、容错、降级,避免出现级联问题

   * 结构：在国内最知名的微服务技术框架就是SpringCloud和阿里巴巴Dubbo。

   * 技术对比

     ![image-20220616225122343](https://whymechen.oss-cn-chengdu.aliyuncs.com/image/202206162258252.png)
     
   * 微服务功能组件
   
     * 服务注册发现：Eureka、Nacos、Consul
     * 统一配置管理：SpringCloudCofing, Nacos
     * 服务远程调用：openFeign, Dubbo
     * 统一网关路由：SpringCloudGateway,zuul
     * 服务链路监控：Zipkin,Sleuth
     * 流控、降级、保护：Hystix、Sentinel

## Spring Cloud & SpringCloudAlibaba

官网：https://spring.io/projects/spring-cloud/

1. 简介：目前国内使用最广泛的微服务框架

2. SpringCloud和SpringBoot的版本兼容性

   ![image-20220616225638824](https://whymechen.oss-cn-chengdu.aliyuncs.com/image/202206181721335.png)

### 服务拆分及远程调用

1. 服务拆分注意事项：

   * 不同微服务，不重复开发相同业务
   * 微服务数据独立，不访问其他微服务的数据库
   * 微服务可以将自己的业务暴露为接口，供其他服务使用

2. 服务远程调用

   > 1. 注册RestTemplate，注入容器
   >
   >    ![image-20220617224745750](https://whymechen.oss-cn-chengdu.aliyuncs.com/image/202206181721514.png)
   >
   > 2. 服务远程调用RestTemplate
   >
   >    ![image-20220617225833140](https://whymechen.oss-cn-chengdu.aliyuncs.com/image/202206181721414.png)

   > * 基于RestTemplate发起的http请求实现远程调用
   > * http请求做远程调用是与语言无关的调用，只要知道对方的ip、端口、接口路径、请求参数即可。

3. 提供者与消费者

   * 服务提供者与消费者是相对的

### EureKa注册中心

1. 服务调用中的问题

   * 服务消费者该如何获取服务提供者的地址信息?(服务启动时注册自己的信息到eureka，消费者根据服务名向Eureka拉取提供者信息)
   * 如果有多个服务提供者,消费者该如何选择?（利用负载均衡算法）
   * 消费者如何得知服务提供者的健康状态? （服务这每30秒向Eureka发送心跳请求，报告健康状态）

2. eureka的作用

   * EurekaServer：服务端，注册中心
     * 记录服务信息
     * 心跳监控
   * EruekaClient：客户端
     * Provider：服务提供者，将自身信息注册到注册中心，每隔30秒向注册中心发送心跳
     * consumer：服务消费者，根据服务名称从注册中心拉取服务列表，基于服务列表做负载均衡，选中一个微服务后发起远程调用

   ![image-20220618171448837](https://whymechen.oss-cn-chengdu.aliyuncs.com/image/202206181721711.png)

3. 快速入门

   * 搭建注册中心

     ![image-20220618172353099](https://whymechen.oss-cn-chengdu.aliyuncs.com/image/202206181723946.png)

   * 服务注册

     ![image-20220618175957800](https://whymechen.oss-cn-chengdu.aliyuncs.com/image/202206181800933.png)

     模拟多实例部署：

     ![image-20220618215953095](https://whymechen.oss-cn-chengdu.aliyuncs.com/image/202206182200358.png)

   * 服务发现

     ![image-20220618220255386](https://whymechen.oss-cn-chengdu.aliyuncs.com/image/202206182202134.png)

### Ribbon负载均衡

#### 相关概念理解（开发角度）

**集群**：可以将其理解为由多个计算节点（称为"节点"）组成的分布式系统。这些节点通过网络连接在一起，共同协作完成某项任务。在集群中，每个节点都运行相同的应用程序或服务，并且可以独立地处理请求和执行任务。通过将工作负载分布到多个节点上，集群能够提高系统的可靠性、性能和扩展能力。

以下是一些从开发角度理解"集群"的关键概念：

1. 分布式计算：集群中的节点可以并行执行任务，通过将工作负载分散到多个节点上，可以提高计算速度和吞吐量。开发人员需要设计和实现分布式算法、任务调度和数据共享等机制。
2. 负载均衡：集群中的负载均衡器负责将请求分发到不同的节点上，以确保每个节点负载均衡和避免单点故障。开发人员需要了解负载均衡算法和配置，以确保请求在集群中被正确路由。
3. 高可用性：通过在集群中运行多个节点，可以提供高可用性。如果一个节点故障，其他节点可以自动接管工作，保证系统的连续性。开发人员需要设计容错和故障恢复机制，以确保系统的可用性和稳定性。
4. 数据一致性：在分布式集群中处理数据时，要考虑如何保持数据的一致性。开发人员需要使用合适的同步或异步机制来确保数据在节点之间的同步和复制。
5. 集群管理：开发人员需要了解如何配置、监视和管理集群中的节点。这包括节点的启动和停止、部署应用程序、监控集群性能和资源使用情况等。

**负载**：以将其理解为指在系统中产生的工作量或任务数量。负载可以是一段时间内进入系统的请求数量、并发用户数量、CPU利用率、内存使用量以及网络流量等。

以下是一些常见的负载类型：

1. 网络负载：指进入和离开系统的网络流量，包括传入和传出的数据包数量、带宽利用率等。网络负载通常出现在需要处理大量网络请求或传输大量数据的应用程序中。
2. 计算负载：指CPU的使用情况，包括计算密集型任务（如大规模数据处理、复杂算法计算）对CPU资源的需求以及CPU的利用率。开发人员需要考虑如何优化算法、并发处理以及任务调度，以提高计算负载的效率。
3. 存储负载：指对存储系统的访问和使用情况，包括读取和写入的数据量、I/O操作的延迟等。存储负载常常出现在需要频繁读写大量数据的应用程序中，例如数据库、文件服务器等。
4. 内存负载：指系统中正在使用的内存量和内存管理的情况，包括内存使用率、内存泄漏、内存交换等。开发人员需要注意内存资源的管理和优化，确保系统在处理大量数据时不会出现内存不足的问题。
5. 并发负载：指同时处理的请求数量或并发用户数量。开发人员需要考虑如何设计并发安全的代码、使用合适的线程池和调度机制，以应对高并发场景下的负载压力。

理解负载可以帮助开发人员了解应用程序的性能瓶颈以及系统资源的使用情况。通过监测和分析负载，开发人员可以进行性能调优、优化资源分配、实现负载均衡等措施，以提高系统的可靠性、性能和可扩展性。

**负载均衡**：可以将其理解为一种分发工作负载的技术，用于在分布式系统中平衡各个节点之间的负载，以提高系统的性能、可靠性和可扩展性。

负载均衡的主要目标是将请求合理地分发到集群中的不同节点上，避免某些节点过载而导致性能下降或服务不可用的情况。通过均衡负载，可以实现以下好处：

1. 提高系统性能：负载均衡可将请求分散到多个节点上，从而减轻单个节点的压力，提高请求的处理速度和响应时间。
2. 增强系统可靠性：当某个节点发生故障或下线时，负载均衡器可以自动将请求路由到其他健康的节点，确保系统的连续性和可用性。
3. 扩展系统容量：通过添加更多的节点，并使用负载均衡技术将请求均匀地分布到这些节点上，可以实现系统的横向扩展，提供更大的容量和处理能力。
4. 简化系统管理：负载均衡器可以通过监控、检测节点的状态和负载情况来自动调整请求的路由，降低管理和维护的复杂性。

常见的负载均衡策略包括：

1. 轮询（Round Robin）：按顺序将请求依次分发到每个节点。
2. 最小连接数（Least Connections）：将请求发送到当前连接数最少的节点，以实现负载均衡。
3. 响应时间（Response Time）：根据节点的响应时间来选择负载均衡的节点，将请求分发到最快的节点上。
4. IP散列（IP Hash）：根据客户端的IP地址进行散列计算，将同一客户端的请求始终发送到同一个节点上。
5. 内容散列（Content Hash）：根据请求的内容进行散列计算，确保相同内容的请求始终由同一个节点处理。

开发人员需要根据具体的应用场景和需求选择适合的负载均衡策略，并配置负载均衡器以实现系统的负载均衡。同时还需要考虑负载均衡器的高可用性、性能监控和故障恢复等方面，以确保负载均衡的有效运行。

#### Ribbon

1. 负载均衡流程

   ![image-20230505181246896](https://whymechen.oss-cn-chengdu.aliyuncs.com/image/202305051812821.png)

   ![image-20220619111733756](https://whymechen.oss-cn-chengdu.aliyuncs.com/image/202206191119756.png)

2. 负载均衡策略

   ![image-20220619111906061](https://whymechen.oss-cn-chengdu.aliyuncs.com/image/202206191124670.png)

   ![image-20220619111926430](https://whymechen.oss-cn-chengdu.aliyuncs.com/image/202206191124252.png)

   ![image-20220619112416337](https://whymechen.oss-cn-chengdu.aliyuncs.com/image/202206191124665.png)

   > 注意：第一种方式针对全局，第二种方式只针对指定服务

3. 饥饿加载

   ![image-20220619113011093](https://whymechen.oss-cn-chengdu.aliyuncs.com/image/202206191130698.png)

### Nacos

GitHub主页：https://github.com/alibaba/nacos

GitHub的Release：https://github.com/alibaba/nacos/releases

网站：https://nacos.io/zh-cn/index.html

1. 安装nacos

   * 下载：在Nacos的GitHub页面，提供有下载链接，可以下载编译好的Nacos服务端或者源代码。
   * 配置：Nacos的默认端口是8848，若电脑上的其它进程占用了8848端口，请先尝试关闭该进程。**如果无法关闭占用8848端口的进程**，也可以进入nacos的conf目录中的配置文件application.properties修改的端口。
   * 启动
     * 双击bin目录中的startup.cmd
     * 执行命令startup.cmd -m standalone
   * 访问：在浏览器输入地址：http://127.0.0.1:8848/nacos即可，登录默认的账号和密码都是nacos进入。

#### 服务注册发现

2. nacos的依赖（客户端）

   父工程：

   ```xml
   <dependency>
       <groupId>com.alibaba.cloud</groupId>
       <artifactId>spring-cloud-alibaba-dependencies</artifactId>
       <version>2.2.5.RELEASE</version>
       <type>pom</type>
       <scope>import</scope>
   </dependency>
   ```

   客户端：

   ```xml
   <!-- nacos客户端依赖包 -->
   <dependency>
       <groupId>com.alibaba.cloud</groupId>
       <artifactId>spring-cloud-starter-alibaba-nacos-discovery</artifactId>
   </dependency>
   ```

3. 客户端注册

   ![image-20220621222022415](https://whymechen.oss-cn-chengdu.aliyuncs.com/image/202206232155659.png)

   ![image-20220621222249577](https://whymechen.oss-cn-chengdu.aliyuncs.com/image/202206232155264.png)

4. nacos服务分级存储模型

   * 分级存储模型
     * 一级是服务
     * 二级是集群
     * 三级是实例

   ![image-20220623215211993](https://whymechen.oss-cn-chengdu.aliyuncs.com/image/202206232155127.png)

   * 服务跨集群调用的问题

     * 服务调用尽可能选择本地集群服务，跨集群调用延迟较高。只有本地集群不可访问时，再去访问其他集群。

   * 配置服务集群属性

     ![image-20220623215446583](https://whymechen.oss-cn-chengdu.aliyuncs.com/image/202206232155960.png)

   * 根据集群负载均衡

     ~~~yaml
     userservice:
       ribbon:
         NFLoadBalancerRuleCalssName: com.alibaba.cloud.nacos.ribbon.NacosRule # 负载均衡规则
     ~~~

     > NacosRule负载均衡策略
     >
     > * 优先选择同集群服务实例列表
     > * 本地集群找不到提供者，才去其它集群寻找，并且会
     >   报警告
     > * 确定了可用实例列表后，再采用随机负载均衡挑选实

   * 根据权重负载均衡

     * 实际部署场景：
       * 服务器设备性能存在差异，部分实例所在机器性能较好，另一些较差，我们希望性能好的机器承担更多的用户请求
     * 通过nacos控制台配置权重：0~1之间同集群内的多个实例，权重越高被访问的频率越高，权重设置为0则完全不会被访问

5. 临时实例和非临时实例

   ![image-20230505211240620](https://whymechen.oss-cn-chengdu.aliyuncs.com/image/202305052112776.png)

6. 环境隔离-namespace：Nacos中服务存储和数据存储的最外层都是一个名为namespace的东西，用来做最外层隔离

   * 在Nacos控制台创建namespace，用来隔离不同环境

   * 在服务的配置文件中配置命名空间

     ![image-20230505205906511](https://whymechen.oss-cn-chengdu.aliyuncs.com/image/202305052059197.png)

   > namespace用来做环境隔离，每个namespace都有唯一id，**不同namespace下的服务不可见**

7. Nacos和Eureka对比

   * 共同点
     * 都支持服务注册和服务拉取
     * 都支持服务提供者心跳方式做健康检测
   * 不同点
     * Nacos支持服务端主动检测提供者状态：临时实例采用心跳模式，非临时实例采用主动检测模式
     * 临时实例心跳不正常会被剔除，非临时实例则不会被剔除
     * Nacos支持服务列表变更的消息推送模式，服务列表更新更及时
     * Nacos集群默认采用AP方式，当集群中存在非临时实例时，采用CP模式；Eureka采用AP方式

#### 配置管理

##### 统一配置管理

> * 在Nacos中添加配置文件
> * 在微服务中引入nacos的config依赖
> * 在微服务中添加bootstrap.yml，配置nacos地址、当前环境、服务名称、文件后缀名。这些决定了程序
>   启动时去nacos读取哪个文件

1. 在nacos中创建配置文件

   ![image-20230505222635283](https://whymechen.oss-cn-chengdu.aliyuncs.com/image/202305052226057.png)

2. 配置获取

   ![image-20230505225825641](https://whymechen.oss-cn-chengdu.aliyuncs.com/image/202305052258264.png)

   ~~~yaml
   spring:
     application:
       name: userservice # 服务名称
     profiles:
       active: dev # 开发环境
     cloud:
       nacos:
         config:
           file-extension: yaml # 文件后缀名
         server-addr: localhost:8848 # Nacos地址
   ~~~

##### 配置热更新

1. 方式一：

   ![image-20230506171558427](https://whymechen.oss-cn-chengdu.aliyuncs.com/image/202305061716283.png)

2. 方式二：

   ![image-20230506172743217](https://whymechen.oss-cn-chengdu.aliyuncs.com/image/202305061727103.png)

##### 配置共享

1. 创建多配置文件

   ![image-20230506173120433](https://whymechen.oss-cn-chengdu.aliyuncs.com/image/202305061745737.png)

2. 多配置文件优先级：[服务名]-[环境].yaml>[服务名].yaml>本地配置

##### 搭建Nacos集群

1. 步骤
   * 搭建MySQL集群并初始化数据库表
   * 下载解压nacos
   * 修改集群配置(节点信息)数据库配置
   * 分别启动多个nacos节点
   * nginx反向代理

### Feign

#### RestTemplate的问题

![image-20230506175657177](https://whymechen.oss-cn-chengdu.aliyuncs.com/image/202305061756412.png)

#### Feign

官网：https://github.com/OpenFeign/feign

1. feign：一个声明式的http客户端，实现优雅的http请求发送。

2. feign客户端的使用

   * 引入依赖

     ~~~xml
     <dependency>            <groupId>org.springframework.cloud</groupId>
      <artifactId>spring-cloud-starter-openfeign</artifactId>
       </dependency>
     ~~~

   * 启动类中添加注解开启Feign功能

     ![image-20230506180353483](https://whymechen.oss-cn-chengdu.aliyuncs.com/image/202305061803740.png)

   * 编写Feign客户端

     ![image-20230506180828135](https://whymechen.oss-cn-chengdu.aliyuncs.com/image/202305061808526.png)

3. 自定义feign配置

   ![image-20230506213938619](https://whymechen.oss-cn-chengdu.aliyuncs.com/image/202305062139929.png)

   日志自定义方式一：配置文件

   ![image-20230506222903876](https://whymechen.oss-cn-chengdu.aliyuncs.com/image/202305062229450.png)

   日志自定义方式二：java代码

   ![image-20230506223002338](https://whymechen.oss-cn-chengdu.aliyuncs.com/image/202305062230717.png)

4. Feign的性能优化

   ![image-20230506223822399](https://whymechen.oss-cn-chengdu.aliyuncs.com/image/202305062238506.png)

   * 连接池配置

     ![image-20230506224047084](https://whymechen.oss-cn-chengdu.aliyuncs.com/image/202305062240233.png)

5. 最佳实践

   * 方式一：

     ![image-20230506224848056](https://whymechen.oss-cn-chengdu.aliyuncs.com/image/202305062248178.png)

   * 方式二：

     ![image-20230506225107978](https://whymechen.oss-cn-chengdu.aliyuncs.com/image/202305062251195.png)

     > 实现步骤：
     >
     > * 创建一个module，命名为feign-api，引入feign相关依赖
     > * 将order-service中编写的UserClient、User、DefaultFeignConfiguration都复制到feign-api项目中
     > * 在order-service中引入feign-api的依赖
     > * 修改order-service中的所有与上述三个组件有关的import部分，改成导入feign-api中的包
     >
     > ![image-20230506231053347](https://whymechen.oss-cn-chengdu.aliyuncs.com/image/202305062310886.png)

### 统一网关Gateway

#### 简介

1. 网关功能
   * 身份认证和权限校验
   * 服务路由和负责均衡
   * 请求限流
2. SpringCloud的网关实现
   * gateway：基于Spring5中提供的WebFlux，属于响应式编程的实现，具备更好的性能。
   * zuul：基于Servlet的实现，属于阻塞式编程。

#### 搭建网关服务

1. 步骤：

   * 创建新的module，引入SpringCloudGateway的依赖和nacos的服务发现依赖

     ![image-20230506231549166](https://whymechen.oss-cn-chengdu.aliyuncs.com/image/202305062315923.png)

   * 编写路由配置及nacos地址

     > 网关路由可以配置的内容包括
     >
     > * 路由id:路由唯一标示
     > * uri: 路由目的地，支持lb和http两种
     > * predicates: 路由断言，判断请求是否符合要求，符合则转发到路由目的地址
     > * filters:路由过滤器，处理请求或响应

     ~~~xml
     server:
       port: 10086
     spring:
       application:
         name: gateway
       cloud:
         nacos:
           server-addr: localhost:8848
         gateway:
           routes: # 网关路由配置
             - id: user-service # 路由id，自定义，只要唯一即可
               uri: lb://userservice # 路由的目标地址，lb就是负载均衡，后面跟服务名称，还可以使用http://127.0.0.1:8081的方式配置
               predicates: # 路由断言，即判断路由是否符合规则
                 - Path=/user/** # 按照路由路径匹配，只要以/user/开头就匹配
             - id: order-service
               uri: lb://orderservice
               predicates:
                 - Path=/order/**
     ~~~

2. 网关流程

   ![image-20230507115109352](https://whymechen.oss-cn-chengdu.aliyuncs.com/image/202305071151354.png)

3. 路由断言工厂

   > 在配置文件中写的断言规则只是字符串，这些字符串会被Predicate Factory读取并处理，转变为路由判断的条件
   > 例如Path=/user/**是按照路径匹配，这个规则是由orq.springframework.cloud.qateway.handler.predicatePathRoutePredicateFactory类来处理的

   ![image-20230507115523705](https://whymechen.oss-cn-chengdu.aliyuncs.com/image/202305071155592.png)
   
4. 路由过滤器（GatewayFilter）：网关中提供的一种过滤器，可以对进入网关的**请求**和微服务返回的**响应**做处理。

   ![image-20230508225305428](https://whymechen.oss-cn-chengdu.aliyuncs.com/image/202305082253251.png)

   * 局部过滤器：配置在路由下

   ~~~xml
         routes:
           - id: user-service # 路由标示，必须唯一
             uri: lb://userservice # 路由的目标地址
             predicates: # 路由断言，判断请求是否符合规则
               - Path=/user/** # 路径断言，判断路径是否是以/user开头，如果是则符合
             filter:
               - AddRequestHeader=Trueth,Come on whyme-chen!
   ~~~

   * 默认过滤器

   ![image-20230508225828849](https://whymechen.oss-cn-chengdu.aliyuncs.com/image/202305082258640.png)

5. 全局过滤器（GlobalFilter）

   全局过滤器的作用也是处理一切进入网关的请求和微服务响应，与GatewayFilter的作用一样。区别在于GatewayFilter通过配置定义，处理逻辑是固定的。而GlobalFilter的逻辑需要自己写代码实现。

   ![image-20230508230421859](https://whymechen.oss-cn-chengdu.aliyuncs.com/image/202305082304761.png)

6. 过滤器执行顺序

   ![image-20230508231853814](https://whymechen.oss-cn-chengdu.aliyuncs.com/image/202305082318558.png)

   > * 每一个过滤器都必须指定一个int类型的order值，order值越小，优先级越高，执行顺序越靠前.
   > * GlobalFilter通过实现Ordered接口，或者添加@Order注解来指定order值，由我们自己指定路由过滤器和defaultFilter的order由Spring指定，默认是按照声明顺序从1递增。
   > * 当过滤器的order值一样时，会按照 defaultFilter > 路由过滤器>GlobalFilter的顺序执行。

7. 跨域问题处理

   ![image-20230508232228486](https://whymechen.oss-cn-chengdu.aliyuncs.com/image/202305082322188.png)

   ![image-20230508232245310](https://whymechen.oss-cn-chengdu.aliyuncs.com/image/202305082322067.png)

### 服务器容错Sentinel

### 分布式事务Seata

# 消息中间件

## MQ基本概念

1. MQ：全称Message Queue (消息队列)，是在消息的传输过程中保存消息的容器。多用于分布式系统之间进行通信。

2. 优势

   * 应用解耦

   * 削峰填谷：应用系统如果遇到系统请求流量的瞬间猛增，有可能会将系统压垮。有了消息队列可以将大量请求缓存起来，分散到很长一段时间处理，这样可以大大提到系统的稳定性和用户体验。

   * 异步提速

     ![image-20230313225333941](https://whymechen.oss-cn-chengdu.aliyuncs.com/image/202303132253511.png)

3. 劣势

   * 系统可用性降低：系统引入的外部依赖越多，系统稳定性越差。一旦MQ宕机，就会对业务造成影响。
   * 系统复杂性提高
   * 一致性问题

4. MQ应用条件

   * 生产者不需要从消费者处获得反馈
   * 容许短暂的不一致性

5. 常见的MQ产品

   * RabbitMQ
   * RocketMQ
   *  ActiveMQ
   * Kafka
   *  ZeroMQ
   * MetaMq

   ![image-20230313230133285](https://whymechen.oss-cn-chengdu.aliyuncs.com/image/202303132301585.png)

6. AMQP：AMQP，即Advanced Message Queuing Protocol (高级消息队列协议) ,是一个网络协议，是应用层协议的一个开放标准，为面向消息的中间件设计。基于此协议的客户端与消息中间件可传递消息，并不受客户端/中间件不同产品，不同的开发语言等条件的限制。2006年， AMQP规范发布。类比HTTP。

## RabbitMQ

### RabbitMQ简介

![image-20230313232906539](https://whymechen.oss-cn-chengdu.aliyuncs.com/image/202303132329639.png)

![image-20230313232947012](https://whymechen.oss-cn-chengdu.aliyuncs.com/image/202303132329894.png)

![image-20230313233040344](https://whymechen.oss-cn-chengdu.aliyuncs.com/image/202303132330009.png)

![image-20230313233121119](https://whymechen.oss-cn-chengdu.aliyuncs.com/image/202303132331854.png)

### 快速使用

官网：https://www.rabbitmq.com/

1. 下载安装和管控台的使用

   > 使用docker安装rabbitmq：https://blog.csdn.net/weixin_44666439/article/details/127265712?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-0-127265712-blog-124470698.235^v27^pc_relevant_3mothn_strategy_recovery&spm=1001.2101.3001.4242.1&utm_relevant_index=3

2. 使用**简单模式**完成消息传递

   * 创建工程（生产者、消费者）
   * 分别添加依赖
   
   ~~~xml
    <dependency>
         <groupId>com.rabbitmq</groupId>
         <artifactId>amqp-client</artifactId>
         <version>5.16.0</version>
       </dependency>
   ~~~
   
   * 编写生产者发送消息、编写消费者接收消息
   
   ~~~java
   package org.example.producer;
   
   import com.rabbitmq.client.AMQP;
   import com.rabbitmq.client.Channel;
   import com.rabbitmq.client.Connection;
   import com.rabbitmq.client.ConnectionFactory;
   
   import java.io.IOException;
   import java.nio.charset.StandardCharsets;
   import java.util.concurrent.TimeoutException;
   
   /**
    * 简单模式
    * @Author chen
    * @Date 2023/3/25
    * @Version 1.0
    **/
   public class Producer_HelloWorld {
       public static void main(String[] args) throws IOException, TimeoutException {
           //创建连接工厂
           ConnectionFactory connectionFactory = new ConnectionFactory();
           //设置参数
           connectionFactory.setHost("47.120.2.57");
           connectionFactory.setPort(5672);
           connectionFactory.setVirtualHost("demo");
           connectionFactory.setUsername("admin");
           connectionFactory.setPassword("admin");
           //创建连接
           Connection connection = connectionFactory.newConnection();
           //创建Channel
           Channel channel = connection.createChannel();
           //创建队列Quene
           /*
            * queueDeclare方法参数说明
            * String queue,队列名称
         * boolean durable,是否持久化
            * boolean exclusive,是否独占，只能有一个消费者监听该队列。当Connection关闭时，是否删除队列
            * boolean autoDelete,是否自动删除，当该队列没有消费者时，自动删除
            * Map<String, Object> arguments,参数
            */
           AMQP.Queue.DeclareOk declareOk = channel.queueDeclare("hello",true,false,false,null);
           //发送消息
           String body = "hello rabbitmq!";
           /*
            *basicPublish方法参数说明
            * String exchange,交换机名称，简单模式下交换机默认使用“
            * String routingKey,路由名称
            * BasicProperties props,配置信息
            * byte[] body,发送消息数据
            */
           channel.basicPublish("","hello",null,body.getBytes(StandardCharsets.UTF_8));
   
           channel.close();
           connection.close();
       }
   }
   ~~~
   
   ~~~java
   package org.example.consumer;
   
   import com.rabbitmq.client.*;
   
   import java.io.IOException;
   import java.nio.charset.StandardCharsets;
   import java.util.concurrent.TimeoutException;
   
   /**
    * 消费者
    * @Author chen
    * @Date 2023/3/25
    * @Version 1.0
    **/
   public class ConsumerDemo1 {
       public static void main(String[] args) throws IOException, TimeoutException {
           //创建连接工厂
           ConnectionFactory connectionFactory = new ConnectionFactory();
           //设置参数
           connectionFactory.setHost("47.120.2.57");
           connectionFactory.setPort(5672);
           connectionFactory.setVirtualHost("demo");
           connectionFactory.setUsername("admin");
           connectionFactory.setPassword("admin");
           //创建连接
           Connection connection = connectionFactory.newConnection();
           //创建Channel
           Channel channel = connection.createChannel();
           //创建队列Quene
           AMQP.Queue.DeclareOk declareOk = channel.queueDeclare("hello",true,false,false,null);
           //消费消息
           Consumer consumer = new DefaultConsumer(channel){
               /**
                * 这是一个回调方法，当收到消息后会自动执行该方法
                * @param consumerTag 标识
                * @param envelope 获取信息，包括：交换机、路由key
                * @param properties 配置信息
                * @param body 数据
                * @throws IOException
                */
               @Override
               public void handleDelivery(String consumerTag,
                                          Envelope envelope,
                                          AMQP.BasicProperties properties,
                                          byte[] body) throws IOException {
                   System.out.println("consumerTag:"+consumerTag);
                   System.out.println("envelope:"+envelope.getExchange());
                   System.out.println("envelope:"+envelope.getRoutingKey());
                   System.out.println("properties:"+properties);
                   System.out.println("body:"+new String(body));
               }
           };
           channel.basicConsume("hello",true,consumer);
   
       }
   }
   
   ~~~
   
3. 工作队列模式（Work Queues）

   * 特点：与简单模式相比有多个消费者
   * 应用场景：对于任务过重或任务较多情况使用工作队列可以提高任务处理的速度
   * 在一个队列中如果有多个消费者，那么消费者之间对于同一个消息的关系是竞争的关系
   * Work Queues 对于任务过重或任务较多情况使用工作队列可以提高任务处理的速度。例如: 短信服务部署多个只需要有一个节点成功发送即可。

4. Pub/Sub订阅模式

   ![image-20230510215142430](https://whymechen.oss-cn-chengdu.aliyuncs.com/image/202305102151306.png)

5. 路由模式

   ![image-20230511115213003](https://whymechen.oss-cn-chengdu.aliyuncs.com/image/202305111152263.png)

### Spring整合RabbitMQ

## RocketMQ

官网：https://rocketmq.apache.org/zh/

### 简介

RocketMQ是由阿里捐赠给Apache的一款低延迟、高并发、高可用、高可靠的分布式消息中间件。

1. 核心概念
   - **Topic**：消息传输和存储的顶层容器，用于标识同一类业务逻辑的消息。主题通过TopicName来做唯一标识和区分。
   - **Message**：生产者向Topic发送并最终传送给消费者的数据消息的载体。按照消息传输特性的不同而定义的分类，用于类型管理和安全校验。 Apache RocketMQ 支持的消息类型有
     - 普通消息
     - 顺序消息
     - 事务消息
     - 定时/延时消息
   - **消息属性**：生产者可以为消息定义的属性，包含Message Key和Tag。
   - **Message Key**：消息的业务标识，由消息生产者（Producer）设置，唯一标识某个业务逻辑。
   - **Message ID**：消息的全局唯一标识，由消息队列RocketMQ系统自动生成，唯一标识某条消息。
   - **Tag**：消息标签，二级消息类型，用来进一步区分某个Topic下的消息分类
   - **Producer**：也称为消息发布者，负责生产并发送消息至Topic。
   - **Consumer**：也称为消息订阅者，负责从Topic接收并消费消息。
   - **Broker**：暂存和传输消息
   - **NameServer**：管理Broker
   - **分区**：即Topic Partition，物理上的概念。每个Topic包含一个或多个分区。
   - **消费位点**：每个Topic会有多个分区，每个分区会统计当前消息的总条数，这个称为最大位点MaxOffset；分区的起始位置对应的位置叫做起始位点MinOffset。
   - **Group**：一类生产者或消费者，这类生产者或消费者通常生产或消费同一类消息，且消息发布或订阅的逻辑一致。
   - **Group ID**：Group的标识。
   - **队列**：个Topic下会由一到多个队列来存储消息。
   - **Exactly-Once投递语义**：Exactly-Once投递语义是指发送到消息系统的消息只能被Consumer处理且仅处理一次，即使Producer重试消息发送导致某消息重复投递，该消息在Consumer也只被消费一次。
   - **集群消费**：一个Group ID所标识的所有Consumer平均分摊消费消息。例如某个Topic有9条消息，一个Group ID有3个Consumer实例，那么在集群消费模式下每个实例平均分摊，只消费其中的3条消息。
   - **广播消费**：一个Group ID所标识的所有Consumer都会各自消费某条消息一次。例如某个Topic有9条消息，一个Group ID有3个Consumer实例，那么在广播消费模式下每个实例都会各自消费9条消息。
   - **定时消息**：Producer将消息发送到消息队列RocketMQ服务端，但并不期望这条消息立马投递，而是推迟到在当前时间点之后的某一个时间投递到Consumer进行消费，该消息即定时消息。
   - **延时消息**：Producer将消息发送到消息队列RocketMQ服务端，但并不期望这条消息立马投递，而是延迟一定时间后才投递到Consumer进行消费，该消息即延时消息。
   - **事务消息**：RocketMQ提供类似X/Open XA的分布事务功能，通过消息队列RocketMQ的事务消息能达到分布式事务的最终一致。
   - **顺序消息**：RocketMQ提供的一种按照顺序进行发布和消费的消息类型，分为全局顺序消息和分区顺序消息。
   - **全局顺序消息**：对于指定的一个Topic，所有消息按照严格的先入先出（FIFO）的顺序进行发布和消费。
   - **分区顺序消息**：对于指定的一个Topic，所有消息根据Sharding Key进行区块分区。同一个分区内的消息按照严格的FIFO顺序进行发布和消费。Sharding Key是顺序消息中用来区分不同分区的关键字段，和普通消息的Message Key是完全不同的概念。
   - **消息堆积**：Producer已经将消息发送到消息队列RocketMQ的服务端，但由于Consumer消费能力有限，未能在短时间内将所有消息正确消费掉，此时在消息队列RocketMQ的服务端保存着未被消费的消息，该状态即消息堆积。
   - **消息过滤**：Consumer可以根据消息标签（Tag）对消息进行过滤，确保Consumer最终只接收被过滤后的消息类型。消息过滤在消息队列RocketMQ的服务端完成。
   - **消息轨迹**：在一条消息从Producer发出到Consumer消费处理过程中，由各个相关节点的时间、地点等数据汇聚而成的完整链路信息。通过消息轨迹，您能清晰定位消息从Producer发出，经由消息队列RocketMQ服务端，投递给Consumer的完整链路，方便定位排查问题。
   - **重置消费位点**：以时间轴为坐标，在消息持久化存储的时间范围内（默认3天），重新设置Consumer对已订阅的Topic的消费进度，设置完成后Consumer将接收设定时间点之后由Producer发送到消息队列RocketMQ服务端的消息。
   - **死信队列**：死信队列用于处理无法被正常消费的消息。当一条消息初次消费失败，消息队列RocketMQ会自动进行消息重试；达到最大重试次数后，若消费依然失败，则表明Consumer在正常情况下无法正确地消费该消息。此时，消息队列RocketMQ不会立刻将消息丢弃，而是将这条消息发送到该Consumer对应的特殊队列中。  消息队列RocketMQ将这种正常情况下无法被消费的消息称为死信消息（Dead-Letter Message），将存储死信消息的特殊队列称为死信队列（Dead-Letter Queue）。

### 快速入门

[快速开始](https://rocketmq.apache.org/zh/docs/quickStart/01quickstart)

### 集群搭建

![RocketMQ角色](微服务技术.assets/RocketMQ角色-1690212428594.jpg)

1. 特点
   * NameServer是一个几乎无状态节点，可集群部署，节点之间无任何信息同步。
   * Broker部署相对复杂，Broker分为Master与Slave，一个Master可以对应多个Slave，但是一个Slave只能对应一个Master，Master与Slave的对应关系通过指定相同的BrokerName，不同的BrokerId来定义，BrokerId为0表示Master，非0表示Slave。Master也可以部署多个。每个Broker与NameServer集群中的所有节点建立长连接，定时注册Topic信息到所有NameServer。
   * Producer与NameServer集群中的其中一个节点（随机选择）建立长连接，定期从NameServer取Topic路由信息，并向提供Topic服务的Master建立长连接，且定时向Master发送心跳。Producer完全无状态，可集群部署。
   * Consumer与NameServer集群中的其中一个节点（随机选择）建立长连接，定期从NameServer取Topic路由信息，并向提供Topic服务的Master、Slave建立长连接，且定时向Master、Slave发送心跳。Consumer既可以从Master订阅消息，也可以从Slave订阅消息，订阅规则由Broker配置决定。
2. 集群模式
   * 单Master模式：这种方式风险较大，一旦Broker重启或者宕机时，会导致整个服务不可用。不建议线上环境使用,可以用于本地测试。
   * 多Master模式：一个集群无Slave，全是Master，例如2个Master或者3个Master，这种模式的优点是配置简单，单个Master宕机或重启维护对应用无影响，在磁盘配置为RAID10时，即使机器宕机不可恢复情况下，由于RAID10磁盘非常可靠，消息也不会丢（异步刷盘丢失少量消息，同步刷盘一条不丢），性能最高；缺点是单台机器宕机期间，这台机器上未被消费的消息在机器恢复之前不可订阅，消息实时性会受到影响。
   * 多Master多Slave模式（异步）：每个Master配置一个Slave，有多对Master-Slave，HA采用异步复制方式，主备有短暂消息延迟（毫秒级），这种模式的优点是即使磁盘损坏，消息丢失的非常少，且消息实时性不会受影响，同时Master宕机后，消费者仍然可以从Slave消费，而且此过程对应用透明，不需要人工干预，性能同多Master模式几乎一样；缺点是Master宕机，磁盘损坏情况下会丢失少量消息。
   * 多Master多Slave模式（同步）：每个Master配置一个Slave，有多对Master-Slave，HA采用同步双写方式，即只有主备都写成功，才向应用返回成功，这种模式的优点是数据与服务都无单点故障，Master宕机情况下，消息无延迟，服务可用性与数据可用性都非常高；缺点是性能比异步复制模式略低（大约低10%左右），发送单个消息的RT会略高，且目前版本在主节点宕机后，备机不能自动切换为主机。

### 消息

1. 构成
   * **topic**，表示要发送的消息的主题。
   * **body** 表示消息的存储内容
   * **properties** 表示消息属性
   * **transactionId** 会在事务消息中使用。

普通消息

顺序消息

事务消息

定时/延时消息

### Java客户端

官网示例：https://rocketmq.apache.org/zh/docs/sdk/02java

#### 发送普通消息

同步消息

~~~java
package com.whymechen.demorocket.common;

import org.apache.rocketmq.client.exception.MQBrokerException;
import org.apache.rocketmq.client.exception.MQClientException;
import org.apache.rocketmq.client.producer.DefaultMQProducer;
import org.apache.rocketmq.client.producer.SendResult;
import org.apache.rocketmq.common.message.Message;
import org.apache.rocketmq.remoting.exception.RemotingException;

import java.nio.charset.StandardCharsets;

/**
 * @author： chenwenjian
 * @date： 2023/7/26 11:01
 * @description： 同步发送普通消息
 * @modifiedBy：
 * @version: 1.0
 */
public class SyncCommonMessage {
    public static void main(String[] args) {
        // 创建生产者并设置生产组
        DefaultMQProducer commonMessage = new DefaultMQProducer("COMMON_MESSAGE");
        // 设置nameserver地址
        commonMessage.setNamesrvAddr("localhost:9876");
        try {
            // 启动producer
            commonMessage.start();
        } catch (MQClientException e) {
            throw new RuntimeException(e);
        }
        // 构建消息，指定topic、tag、body等信息
        for (int i = 0; i < 10; i++) {
            String msg = "msg"+i+"：Hello Rocket";
            Message message = new Message("commonMsg", "tag1", msg.getBytes(StandardCharsets.UTF_8));
            SendResult send;
            try {
                // 发送消息
                send = commonMessage.send(message);
            } catch (MQClientException | RemotingException | MQBrokerException | InterruptedException e) {
                throw new RuntimeException(e);
            }
            System.out.println("msg"+i+"：发送成功！msgId为"+send.getMsgId());
        }
        // 关闭producer
        commonMessage.shutdown();
    }
}

~~~

异步消息

~~~java
package com.whymechen.demorocket.common;

import org.apache.rocketmq.client.exception.MQClientException;
import org.apache.rocketmq.client.producer.DefaultMQProducer;
import org.apache.rocketmq.client.producer.SendCallback;
import org.apache.rocketmq.client.producer.SendResult;
import org.apache.rocketmq.common.message.Message;
import org.apache.rocketmq.remoting.exception.RemotingException;

import java.nio.charset.StandardCharsets;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.TimeUnit;

/**
 * @author： chenwenjian
 * @date： 2023/7/26 12:53
 * @description： 异步发送普通消息，异步发送一般用于链路耗时较长，对响应时间较为敏感的业务场景。例如，视频上传后通知启动转码服务，转码完成后通知推送转码结果等。
 * @modifiedBy：
 * @version: 1.0
 */
public class AsyncCommonMessage {
    public static void main(String[] args) throws InterruptedException {
        DefaultMQProducer commonMessage = new DefaultMQProducer("COMMON_MESSAGE");
        commonMessage.setNamesrvAddr("localhost:9876");
        try {
            commonMessage.start();
            commonMessage.setRetryTimesWhenSendAsyncFailed(0);
        } catch (MQClientException e) {
            throw new RuntimeException(e);
        }
        int count = 10;
        final CountDownLatch countDownLatch = new CountDownLatch(count);
        for (int i = 0; i < count; i++) {
            String msg = "async msg"+i+"hello RocketMQ";
            Message message = new Message("commonMsg", "tag2", msg.getBytes(StandardCharsets.UTF_8));
            try {
                commonMessage.send(message, new SendCallback() {
                    @Override
                    public void onSuccess(SendResult sendResult) {
                        System.out.println("消息发送成功!msgId为"+sendResult.getMsgId());
                        countDownLatch.countDown();

                    }

                    @Override
                    public void onException(Throwable throwable) {
                        System.out.println("消息发送失败!失败原因为"+throwable.getMessage());
                        countDownLatch.countDown();
                    }
                });
            } catch (MQClientException | RemotingException | InterruptedException e) {
                throw new RuntimeException(e);
            }
        }
        //异步发送，如果要求可靠传输，必须要等回调接口返回明确结果后才能结束逻辑，否则立即关闭Producer可能导致部分消息尚未传输成功
        countDownLatch.await(5, TimeUnit.SECONDS);
        commonMessage.shutdown();
    }
}

~~~

单向模式

```java
package com.whymechen.demorocket.common;

import org.apache.rocketmq.client.exception.MQClientException;
import org.apache.rocketmq.client.producer.DefaultMQProducer;
import org.apache.rocketmq.common.message.Message;
import org.apache.rocketmq.remoting.exception.RemotingException;

import java.nio.charset.StandardCharsets;

/**
 * @author： chenwenjian
 * @date： 2023/7/26 13:53
 * @description： 单向模式发送普通消息，此方式发送消息的过程耗时非常短，一般在微秒级别。适用于某些耗时非常短，但对可靠性要求并不高的场景，例如日志收集。
 * @modifiedBy：
 * @version: 1.0
 */
public class OneWayCommonMessage {
    public static void main(String[] args) throws MQClientException, RemotingException, InterruptedException {
        DefaultMQProducer commonMessage = new DefaultMQProducer("COMMON_MESSAGE");
        commonMessage.setNamesrvAddr("localhost:9876");
        commonMessage.start();
        for (int i = 0; i < 5; i++) {
            Message message = new Message("commonMsg", "tag3", ("one wag message" + i).getBytes(StandardCharsets.UTF_8));
            commonMessage.sendOneway(message);
        }

        commonMessage.shutdown();
    }
}
```

#### 发送顺序消息

```java
package com.whymechen.demorocket.sequence;

import org.apache.rocketmq.client.exception.MQBrokerException;
import org.apache.rocketmq.client.exception.MQClientException;
import org.apache.rocketmq.client.producer.DefaultMQProducer;
import org.apache.rocketmq.client.producer.SendResult;
import org.apache.rocketmq.common.message.Message;
import org.apache.rocketmq.remoting.common.RemotingHelper;
import org.apache.rocketmq.remoting.exception.RemotingException;

import java.io.UnsupportedEncodingException;

/**
 * @author： chenwenjian
 * @date： 2023/7/26 14:13
 * @description：
 * @modifiedBy：
 * @version: 1.0
 */
public class SequenceMessage {
    public static void main(String[] args) throws UnsupportedEncodingException {
        DefaultMQProducer producer = null;
        try {
            producer = new DefaultMQProducer("SEQUENCE_MESSAGE");
            producer.setNamesrvAddr("localhost:9876");
            producer.start();

            String[] tags = new String[]{"TagA", "TagB", "TagC", "TagD", "TagE"};
            for (int i = 0; i < 50; i++) {
                int orderId = i % 10;
                Message msg = new Message("secquenceMsg", tags[i % tags.length], "KEY" + i,
                                ("Hello RocketMQ " + i).getBytes(RemotingHelper.DEFAULT_CHARSET));
                SendResult sendResult = producer.send(msg, (mqs, msg1, arg) -> {
                    Integer id = (Integer) arg;
                    int index = id % mqs.size();
                    return mqs.get(index);
                }, orderId);

                System.out.printf("%s%n", sendResult);
            }
        } catch (MQClientException | RemotingException | MQBrokerException | InterruptedException e) {
            e.printStackTrace();
        }finally {
           if (producer!=null){
               producer.shutdown();
           }
        }
    }
}
```

MessageQueueSelector的接口如下：

```java
public interface MessageQueueSelector {
    MessageQueue select(final List<MessageQueue> mqs, final Message msg, final Object arg);
}
```

其中 mqs 是可以发送的队列，msg是消息，arg是上述send接口中传入的Object对象，返回的是该消息需要发送到的队列。上述例子里，是以orderId作为分区分类标准，对所有队列个数取余，来对将相同orderId的消息发送到同一个队列中。

生产环境中建议选择最细粒度的分区键进行拆分，例如，将订单ID、用户ID作为分区键关键字，可实现同一终端用户的消息按照顺序处理，不同用户的消息无需保证顺序。

# 持续集成

## Docker

视频：https://www.bilibili.com/video/BV1CJ411T7BK?p=1

文档：

* https://pdai.tech/md/devops/docker/docker-00-overview.html

### 简介

1. 容器：

   * **解决软件跨环境迁移问题**
   * 完全使用沙箱机制，相互隔离
   * 性能开销极低

2. Docker：一个开源的应用容器引擎

   * 官网：https://www.docker.com
   * 诞生于2013年初,基于Go语言实现，dotCloud 公司出品(后改名为Docker Inc)
   * Docker可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的Linux机器上。
   * Docker从17.03版本之后分为CE (Community Edition:社区版)和EE (Enterprise Edition:企业版)

3. docker架构

   ![image-20230311195708638](https://whymechen.oss-cn-chengdu.aliyuncs.com/image/202303111957973.png)

4. 配置镜像加速器

   阿里云：https://cr.console.aliyun.com/cn-heyuan/instances/mirrors

   网易加速器：http://hub-mirror.c.163.com

   Docker官方中国加速器：https://registry.docker-cn.com

   ustc 的镜像：https://docker.mirrors.ustc.edu.cn

   daocloud：https://www.daocloud.io/mirror#accelerator-doc（注册后使用）

5. docker容器虚拟化和传统虚拟机虚拟化的比较

   ![image-20230311230728514](https://whymechen.oss-cn-chengdu.aliyuncs.com/image/202303112307226.png)
   
6. 重要概念

   * images
   * container

### 常用命令

1. 服务相关

   > 启动docker服务：system start docker
   >
   > 停止docker服务：system stop docker
   >
   > 重启docker服务：system restart docker
   >
   > 查看docker服务状态：system status docker
   >
   > 开机启动docker服务：system enable docker

2. 镜像相关命令

   镜像地址：https://hub.docker.com/

   > 查看镜像：docker images
   >
   > 搜索镜像：docker search
   >
   > 拉取镜像：docker pull
   >
   > 删除镜像：docker rmi

3. 容器相关命令

   > 查看正在运行的容器：docker ps
   >
   > ​	-a：表示查看所有容器
   >
   > 创建容器：docker run 
   >
   > ​	-i：保持容器运行。通常与-t同时使用。加入it这两个参数后,容器创建后自动进入容器中，退出容器后，容器自动关闭。
   >
   > ​	-t: 为容器重新分配一个伪输入终端，通常与-i同时使用。
   > ​	-d:以守护(后台)模式运行容器。创建一个容器在后台运行， 需要使用dockerexec进入容器。退出后，容器不会关闭。
   > ​	-it创建的容器-般称为交互式容器， -id 创建的容器一般称为守护式容器
   > ​	--name:为创建的容器命名。
   >
   > 进入容器：docker exec
   > 启动容器：docker start
   > 停止容器：docker stop
   > 删除容器：docker rm
   > 查看容器信息：docker inspect

### 容器数据卷

1. 数据卷：数据卷是宿主机中的一个目录或文件

   * 当容器目录和数据卷目录绑定后，对方的修改会立即同步
   * 一个数据卷可以被多个容器同时挂载
   * 一个容器也可以被挂载多个数据卷

2. 作用

   * 容器数据持久化
   * 外部机器和容器间接通信
   * 容器之间数据交换

3. 配置数据卷

   > docker run ... -v 宿主机目录(文件) :容器内目录(文件)
   >
   > 注意事项：
   >
   > * 目录必须是绝对路径
   > * 如果目录不存在,会自动创建
   > * 可以挂载多个数据卷

4. 数据卷容器

   ![image-20230311213730377](https://whymechen.oss-cn-chengdu.aliyuncs.com/image/202303112137385.png)

### Dockerfile

#### 镜像原理

docker镜像原理：**docker镜像的本质是一个分层文件系统**

![image-20230311215746393](https://whymechen.oss-cn-chengdu.aliyuncs.com/image/202303112157213.png)

#### 镜像制作

##### 基于容器制作

![image-20230311220359398](https://whymechen.oss-cn-chengdu.aliyuncs.com/image/202303112204252.png)

##### 基于dockerfile文件制作

1. 简介

   * Dockerfile是一个文本文件
   * 包含了一条条的指令，每一条指令构建一层,基于基础镜像，最终构建出一一个新的镜像
   * 对于开发人员:可以为开发团队提供一个完全一致的开发环境
   * 对于测试人员:可以直接拿开发时所构建的镜像或者通过Dockerfile文件构建一个新的镜像开始工作
   * 对于运维人员:在部署时，可以实现应用的无缝移植

2. 常见关键字

   | 关键字      | 作用                     | 备注                                                         |
   | ----------- | ------------------------ | ------------------------------------------------------------ |
   | FROM        | 指定父镜像               | 指定dockerfile基于那个image构建                              |
   | MAINTAINER  | 作者信息                 | 用来标明这个dockerfile谁写的                                 |
   | LABEL       | 标签                     | 用来标明dockerfile的标签 可以使用Label代替Maintainer 最终都是在docker image基本信息中可以查看 |
   | RUN         | 执行命令                 | 执行一段命令 默认是/bin/sh 格式: RUN command 或者 RUN ["command" , "param1","param2"] |
   | CMD         | 容器启动命令             | 提供启动容器时候的默认命令 和ENTRYPOINT配合使用.格式 CMD command param1 param2 或者 CMD ["command" , "param1","param2"] |
   | ENTRYPOINT  | 入口                     | 一般在制作一些执行就关闭的容器中会使用                       |
   | COPY        | 复制文件                 | build的时候复制文件到image中                                 |
   | ADD         | 添加文件                 | build的时候添加文件到image中 不仅仅局限于当前build上下文 可以来源于远程服务 |
   | ENV         | 环境变量                 | 指定build时候的环境变量 可以在启动的容器的时候 通过-e覆盖 格式ENV name=value |
   | ARG         | 构建参数                 | 构建参数 只在构建的时候使用的参数 如果有ENV 那么ENV的相同名字的值始终覆盖arg的参数 |
   | VOLUME      | 定义外部可以挂载的数据卷 | 指定build的image那些目录可以启动的时候挂载到文件系统中 启动容器的时候使用 -v 绑定 格式 VOLUME ["目录"] |
   | EXPOSE      | 暴露端口                 | 定义容器运行的时候监听的端口 启动容器的使用-p来绑定暴露端口 格式: EXPOSE 8080 或者 EXPOSE 8080/udp |
   | WORKDIR     | 工作目录                 | 指定容器内部的工作目录 如果没有创建则自动创建 如果指定/ 使用的是绝对地址 如果不是/开头那么是在上一条workdir的路径的相对路径 |
   | USER        | 指定执行用户             | 指定build或者启动的时候 用户 在RUN CMD ENTRYPONT执行的时候的用户 |
   | HEALTHCHECK | 健康检查                 | 指定监测当前容器的健康监测的命令 基本上没用 因为很多时候 应用本身有健康监测机制 |
   | ONBUILD     | 触发器                   | 当存在ONBUILD关键字的镜像作为基础镜像的时候 当执行FROM完成之后 会执行 ONBUILD的命令 但是不影响当前镜像 用处也不怎么大 |
   | STOPSIGNAL  | 发送信号量到宿主机       | 该STOPSIGNAL指令设置将发送到容器的系统调用信号以退出。       |
   | SHELL       | 指定执行脚本的shell      | 指定RUN CMD ENTRYPOINT 执行命令的时候 使用的shell            |

### Docker Compose

Docker Compose是一个编排多容器分布式部署的工具，提供命令集管理容器化应用的完整开发周期，包括服务构建启动和停止。使用步骤:

* 利用 Dockerfile定义运行环境镜像
* 使用docker-compose.yml定义组成应用的各服务
* 运行 docker-composeup 启动应用

![image-20230311230230122](https://whymechen.oss-cn-chengdu.aliyuncs.com/image/202303112302382.png)

### Docker 私有仓库

## Rancher

## kubernetes

# 分布式搜索

# 分布式缓存

# 分布式日志

# 分布式事务

# RPC

参考：https://www.bilibili.com/video/BV11i4y1N7LQ/?spm_id_from=333.337.search-card.all.click&vd_source=fabefd3fabfadb9324761989b55c26ea

## Remoting协议

Remoting协议是一种用于分布式系统中的远程过程调用（RPC）的通信协议。它允许不同计算机之间的应用程序通过网络进行通信，以便调用和执行远程计算机上的方法或函数。

Remoting协议的主要目标是使远程调用的过程像本地调用一样简单和透明。它隐藏了底层网络通信的细节，使开发者能够以类似于本地方法调用的方式编写代码。

1. 主要特点：
   * 远程调用透明性：Remoting协议使得远程调用过程对开发者来说是透明的。开发者可以像调用本地方法一样调用远程方法，不需要关注底层的网络通信和序列化过程。
   * 语言无关性：Remoting协议不依赖于特定的编程语言。它可以用于支持多种编程语言之间的远程通信，例如Java、C#、Python等。
   * 传输方式灵活性：Remoting协议支持多种传输方式，如TCP、HTTP等。开发者可以根据需求选择合适的传输方式。
   * 序列化和反序列化支持：Remoting协议提供了序列化和反序列化的支持，用于将方法参数和返回值在不同计算机之间进行传输和还原。这使得对象的跨网络传输变得简单和高效。
   * 异常处理：Remoting协议能够处理远程调用中的异常情况，并将异常信息传递给调用方。这样，开发者可以在远程调用过程中处理异常，确保系统的稳定性和可靠性。
   * Remoting协议通常需要使用专门的框架或库来实现，如Java的RMI（Remote Method Invocation）和.NET的Remoting框架。

## gRPC协议

文档： https://grpc.io/

gRPC（全称为Google Remote Procedure Call）是一种远程过程调用协议，由Google开发并于2015年对外发布。它基于HTTP/2协议，并使用Protocol Buffers作为数据序列化和接口定义语言。

gRPC旨在简化分布式系统间的通信，它支持多种编程语言（如C++, Java, Python等），并提供了强大的功能和性能优势。

1. 主要特点：
   * 高性能：gRPC使用二进制数据格式（Protocol Buffers）和基于HTTP/2的传输协议，具有较低的序列化和网络开销，以及高效的多路复用和流控制机制。这使得gRPC在性能方面比传统的文本协议（如JSON或XML）更加高效。
   * 强大的接口定义和代码生成：gRPC使用基于IDL（Interface Definition Language）的Protocol Buffers来定义服务接口和消息格式。通过定义清晰的接口规范，它能够自动生成跨多种编程语言的客户端和服务器端代码，简化了开发者的工作量。
   * 支持多种通信模式：gRPC支持四种类型的RPC（Remote Procedure Call）方法调用，包括简单的单向调用、服务端流式调用、客户端流式调用和双向流式调用。这使得开发者能够根据具体的需求选择适当的通信模式，实现灵活的数据交互。
   * 提供拦截器和中间件：gRPC支持拦截器和中间件机制，使开发者能够在请求和响应的处理过程中进行自定义操作。这让开发者可以方便地实现认证、日志记录、错误处理等功能，提高代码的可重用性和可维护性。
   * 可扩展性：gRPC提供了扩展能力，允许开发者根据需要添加新的功能和协议扩展。例如，可以通过自定义插件扩展其认证和授权机制，或者添加基于底层传输协议的自定义功能。

# apisix

官网：https://apisix.apache.org/zh/

参考：

* [【云原生网关】apisix使用详解](http://www.rply.cn/news/71253.html)

# 权限管理

## 基本概念

一般指根据系统设置的安全规则或者安全策略，用户可以访问而且只能访问自己被授权的资源。权限管理几乎出现在任何系统里面，前提是需要有用户和密码认证的系统。

1. 重要概念

   * 认证：通过用户名和密码成功登陆系统后，让系统得到当前用户的角色身份。
   * 授权：系统根据当前用户的角色，给其授予对应可以操作的权限资源

2. 权限管理三要素

   * 用户：主要包含用户名，密码和当前用户的角色信息，可实现认证操作。
   * 角色：主要包含角色名称，角色描述和当前角色拥有的权限信息，可实现授权操作。
   * 权限：权限也可以称为菜单，主要包含当前权限名称，url地址等信息，可实现动态展示菜单。

   > 用户与角色是多对多的关系，角色与权限是多对多的关系，用户与权限没有直接关系，二者是通过角色来建立关联关系的。

## 第三方登录

JustAuth：

* 项目地址（gitee）：https://gitee.com/yadong.zhang/JustAuth
* 文档：https://www.justauth.cn/