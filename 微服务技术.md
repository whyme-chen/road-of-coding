# 	微服务技术

## 微服务简介

### 微服务技术栈

1. 服务网关
2. 注册中心
3. 配置中心
4. 服务集群
5. 分布式缓存
6. 分布式搜索
7. 分布式日志框架
8. 统一部署平台

![image-20220616221642790](https://whymechen.oss-cn-chengdu.aliyuncs.com/image/202206162216086.png)

![image-20220616221927980](https://whymechen.oss-cn-chengdu.aliyuncs.com/image/202206162257980.png)

![image-20220616222141070](https://whymechen.oss-cn-chengdu.aliyuncs.com/image/202206162258405.png)

学习课程：[SpringCloud+RabbitMQ+Docker+Redis+搜索+分布式，系统详解springcloud微服务技术栈课程|黑马程序员Java微服务](https://www.bilibili.com/video/BV1LQ4y127n4/?p=1&vd_source=fabefd3fabfadb9324761989b55c26ea)

![image-20230311183945358](https://whymechen.oss-cn-chengdu.aliyuncs.com/image/202303111839545.png)

### 微服务架构演变

1. 单体架构：将业务所有功能集中在一个项目中开发，生成一个包进行部署

   * 优点：架构简单、部署成本低
   * 缺点：耦合度高

2. 分布式架构：根据业务功能对系统拆分，每个业务模块作为一个独立项目开发，称为一个服务。

   * 优点：降低服务耦合度，有利于服务升级扩展
   * 服务治理（分布式架构的要考虑的问题）
     * 服务拆分粒度如何?
     * 服务集群地址如何维护?
     * 服务之间如何实现远程调用?
     * 服务健康状态如何感知?

3. 微服务：**微服务是一种经过良好架构设计的分布式架构方案**

   * 微服务架构特征:

     * 单一职责:微服务拆分粒度更小，每-一个服务都对应唯一的业务能力，做到单一职责,避免重复业务开发
     * 面向服务：微服务对外暴露业务接口
     * 自治：团队独立、技术独立、数据独立、部署独立
     * 隔离性强：服务调用做好隔离、容错、降级,避免出现级联问题

   * 结构：在国内最知名的微服务技术框架就是SpringCloud和阿里巴巴Dubbo。

   * 技术对比

     ![image-20220616225122343](https://whymechen.oss-cn-chengdu.aliyuncs.com/image/202206162258252.png)
     
   * 微服务功能组件
   
     * 服务注册发现：Eureka、Nacos、Consul
     * 统一配置管理：SpringCloudCofing, Nacos
     * 服务远程调用：openFeign, Dubbo
     * 统一网关路由：SpringCloudGateway,zuul
     * 服务链路监控：Zipkin,Sleuth
     * 流控、降级、保护：Hystix、Sentinel

## Spring Cloud & SpringCloudAlibaba

官网：https://spring.io/projects/spring-cloud/

1. 简介：目前国内使用最广泛的微服务框架

2. SpringCloud和SpringBoot的版本兼容性

   ![image-20220616225638824](https://whymechen.oss-cn-chengdu.aliyuncs.com/image/202206181721335.png)

### 服务拆分及远程调用

1. 服务拆分注意事项：

   * 不同微服务，不重复开发相同业务
   * 微服务数据独立，不访问其他微服务的数据库
   * 微服务可以将自己的业务暴露为接口，供其他服务使用

2. 服务远程调用

   > 1. 注册RestTemplate，注入容器
   >
   >    ![image-20220617224745750](https://whymechen.oss-cn-chengdu.aliyuncs.com/image/202206181721514.png)
   >
   > 2. 服务远程调用RestTemplate
   >
   >    ![image-20220617225833140](https://whymechen.oss-cn-chengdu.aliyuncs.com/image/202206181721414.png)

   > * 基于RestTemplate发起的http请求实现远程调用
   > * http请求做远程调用是与语言无关的调用，只要知道对方的ip、端口、接口路径、请求参数即可。

3. 提供者与消费者

   * 服务提供者与消费者是相对的

### EureKa注册中心

1. 服务调用中的问题

   * 服务消费者该如何获取服务提供者的地址信息?(服务启动时注册自己的信息到eureka，消费者根据服务名向Eureka拉取提供者信息)
   * 如果有多个服务提供者,消费者该如何选择?（利用负载均衡算法）
   * 消费者如何得知服务提供者的健康状态? （服务这每30秒向Eureka发送心跳请求，报告健康状态）

2. eureka的作用

   * EurekaServer：服务端，注册中心
     * 记录服务信息
     * 心跳监控
   * EruekaClient：客户端
     * Provider：服务提供者，将自身信息注册到注册中心，每隔30秒向注册中心发送心跳
     * consumer：服务消费者，根据服务名称从注册中心拉取服务列表，基于服务列表做负载均衡，选中一个微服务后发起远程调用

   ![image-20220618171448837](https://whymechen.oss-cn-chengdu.aliyuncs.com/image/202206181721711.png)

3. 快速入门

   * 搭建注册中心

     ![image-20220618172353099](https://whymechen.oss-cn-chengdu.aliyuncs.com/image/202206181723946.png)

   * 服务注册

     ![image-20220618175957800](https://whymechen.oss-cn-chengdu.aliyuncs.com/image/202206181800933.png)

     模拟多实例部署：

     ![image-20220618215953095](https://whymechen.oss-cn-chengdu.aliyuncs.com/image/202206182200358.png)

   * 服务发现

     ![image-20220618220255386](https://whymechen.oss-cn-chengdu.aliyuncs.com/image/202206182202134.png)

### Ribbon负载均衡

#### 相关概念理解（开发角度）

**集群**：可以将其理解为由多个计算节点（称为"节点"）组成的分布式系统。这些节点通过网络连接在一起，共同协作完成某项任务。在集群中，每个节点都运行相同的应用程序或服务，并且可以独立地处理请求和执行任务。通过将工作负载分布到多个节点上，集群能够提高系统的可靠性、性能和扩展能力。

以下是一些从开发角度理解"集群"的关键概念：

1. 分布式计算：集群中的节点可以并行执行任务，通过将工作负载分散到多个节点上，可以提高计算速度和吞吐量。开发人员需要设计和实现分布式算法、任务调度和数据共享等机制。
2. 负载均衡：集群中的负载均衡器负责将请求分发到不同的节点上，以确保每个节点负载均衡和避免单点故障。开发人员需要了解负载均衡算法和配置，以确保请求在集群中被正确路由。
3. 高可用性：通过在集群中运行多个节点，可以提供高可用性。如果一个节点故障，其他节点可以自动接管工作，保证系统的连续性。开发人员需要设计容错和故障恢复机制，以确保系统的可用性和稳定性。
4. 数据一致性：在分布式集群中处理数据时，要考虑如何保持数据的一致性。开发人员需要使用合适的同步或异步机制来确保数据在节点之间的同步和复制。
5. 集群管理：开发人员需要了解如何配置、监视和管理集群中的节点。这包括节点的启动和停止、部署应用程序、监控集群性能和资源使用情况等。

**负载**：以将其理解为指在系统中产生的工作量或任务数量。负载可以是一段时间内进入系统的请求数量、并发用户数量、CPU利用率、内存使用量以及网络流量等。

以下是一些常见的负载类型：

1. 网络负载：指进入和离开系统的网络流量，包括传入和传出的数据包数量、带宽利用率等。网络负载通常出现在需要处理大量网络请求或传输大量数据的应用程序中。
2. 计算负载：指CPU的使用情况，包括计算密集型任务（如大规模数据处理、复杂算法计算）对CPU资源的需求以及CPU的利用率。开发人员需要考虑如何优化算法、并发处理以及任务调度，以提高计算负载的效率。
3. 存储负载：指对存储系统的访问和使用情况，包括读取和写入的数据量、I/O操作的延迟等。存储负载常常出现在需要频繁读写大量数据的应用程序中，例如数据库、文件服务器等。
4. 内存负载：指系统中正在使用的内存量和内存管理的情况，包括内存使用率、内存泄漏、内存交换等。开发人员需要注意内存资源的管理和优化，确保系统在处理大量数据时不会出现内存不足的问题。
5. 并发负载：指同时处理的请求数量或并发用户数量。开发人员需要考虑如何设计并发安全的代码、使用合适的线程池和调度机制，以应对高并发场景下的负载压力。

理解负载可以帮助开发人员了解应用程序的性能瓶颈以及系统资源的使用情况。通过监测和分析负载，开发人员可以进行性能调优、优化资源分配、实现负载均衡等措施，以提高系统的可靠性、性能和可扩展性。

**负载均衡**：可以将其理解为一种分发工作负载的技术，用于在分布式系统中平衡各个节点之间的负载，以提高系统的性能、可靠性和可扩展性。

负载均衡的主要目标是将请求合理地分发到集群中的不同节点上，避免某些节点过载而导致性能下降或服务不可用的情况。通过均衡负载，可以实现以下好处：

1. 提高系统性能：负载均衡可将请求分散到多个节点上，从而减轻单个节点的压力，提高请求的处理速度和响应时间。
2. 增强系统可靠性：当某个节点发生故障或下线时，负载均衡器可以自动将请求路由到其他健康的节点，确保系统的连续性和可用性。
3. 扩展系统容量：通过添加更多的节点，并使用负载均衡技术将请求均匀地分布到这些节点上，可以实现系统的横向扩展，提供更大的容量和处理能力。
4. 简化系统管理：负载均衡器可以通过监控、检测节点的状态和负载情况来自动调整请求的路由，降低管理和维护的复杂性。

常见的负载均衡策略包括：

1. 轮询（Round Robin）：按顺序将请求依次分发到每个节点。
2. 最小连接数（Least Connections）：将请求发送到当前连接数最少的节点，以实现负载均衡。
3. 响应时间（Response Time）：根据节点的响应时间来选择负载均衡的节点，将请求分发到最快的节点上。
4. IP散列（IP Hash）：根据客户端的IP地址进行散列计算，将同一客户端的请求始终发送到同一个节点上。
5. 内容散列（Content Hash）：根据请求的内容进行散列计算，确保相同内容的请求始终由同一个节点处理。

开发人员需要根据具体的应用场景和需求选择适合的负载均衡策略，并配置负载均衡器以实现系统的负载均衡。同时还需要考虑负载均衡器的高可用性、性能监控和故障恢复等方面，以确保负载均衡的有效运行。

#### Ribbon

1. 负载均衡流程

   ![image-20230505181246896](https://whymechen.oss-cn-chengdu.aliyuncs.com/image/202305051812821.png)

   ![image-20220619111733756](https://whymechen.oss-cn-chengdu.aliyuncs.com/image/202206191119756.png)

2. 负载均衡策略

   ![image-20220619111906061](https://whymechen.oss-cn-chengdu.aliyuncs.com/image/202206191124670.png)

   ![image-20220619111926430](https://whymechen.oss-cn-chengdu.aliyuncs.com/image/202206191124252.png)

   ![image-20220619112416337](https://whymechen.oss-cn-chengdu.aliyuncs.com/image/202206191124665.png)

   > 注意：第一种方式针对全局，第二种方式只针对指定服务

3. 饥饿加载

   ![image-20220619113011093](https://whymechen.oss-cn-chengdu.aliyuncs.com/image/202206191130698.png)

### Nacos

GitHub主页：https://github.com/alibaba/nacos

GitHub的Release：https://github.com/alibaba/nacos/releases

网站：https://nacos.io/zh-cn/index.html

1. 安装nacos

   * 下载：在Nacos的GitHub页面，提供有下载链接，可以下载编译好的Nacos服务端或者源代码。
   * 配置：Nacos的默认端口是8848，若电脑上的其它进程占用了8848端口，请先尝试关闭该进程。**如果无法关闭占用8848端口的进程**，也可以进入nacos的conf目录中的配置文件application.properties修改的端口。
   * 启动
     * 双击bin目录中的startup.cmd
     * 执行命令startup.cmd -m standalone
   * 访问：在浏览器输入地址：http://127.0.0.1:8848/nacos即可，登录默认的账号和密码都是nacos进入。

#### 服务注册发现

2. nacos的依赖（客户端）

   父工程：

   ```xml
   <dependency>
       <groupId>com.alibaba.cloud</groupId>
       <artifactId>spring-cloud-alibaba-dependencies</artifactId>
       <version>2.2.5.RELEASE</version>
       <type>pom</type>
       <scope>import</scope>
   </dependency>
   ```

   客户端：

   ```xml
   <!-- nacos客户端依赖包 -->
   <dependency>
       <groupId>com.alibaba.cloud</groupId>
       <artifactId>spring-cloud-starter-alibaba-nacos-discovery</artifactId>
   </dependency>
   ```

3. 客户端注册

   ![image-20220621222022415](https://whymechen.oss-cn-chengdu.aliyuncs.com/image/202206232155659.png)

   ![image-20220621222249577](https://whymechen.oss-cn-chengdu.aliyuncs.com/image/202206232155264.png)

4. nacos服务分级存储模型

   * 分级存储模型
     * 一级是服务
     * 二级是集群
     * 三级是实例

   ![image-20220623215211993](https://whymechen.oss-cn-chengdu.aliyuncs.com/image/202206232155127.png)

   * 服务跨集群调用的问题

     * 服务调用尽可能选择本地集群服务，跨集群调用延迟较高。只有本地集群不可访问时，再去访问其他集群。

   * 配置服务集群属性

     ![image-20220623215446583](https://whymechen.oss-cn-chengdu.aliyuncs.com/image/202206232155960.png)

   * 根据集群负载均衡

     ~~~yaml
     userservice:
       ribbon:
         NFLoadBalancerRuleCalssName: com.alibaba.cloud.nacos.ribbon.NacosRule # 负载均衡规则
     ~~~

     > NacosRule负载均衡策略
     >
     > * 优先选择同集群服务实例列表
     > * 本地集群找不到提供者，才去其它集群寻找，并且会
     >   报警告
     > * 确定了可用实例列表后，再采用随机负载均衡挑选实

   * 根据权重负载均衡

     * 实际部署场景：
       * 服务器设备性能存在差异，部分实例所在机器性能较好，另一些较差，我们希望性能好的机器承担更多的用户请求
     * 通过nacos控制台配置权重：0~1之间同集群内的多个实例，权重越高被访问的频率越高，权重设置为0则完全不会被访问

5. 临时实例和非临时实例

   ![image-20230505211240620](https://whymechen.oss-cn-chengdu.aliyuncs.com/image/202305052112776.png)

6. 环境隔离-namespace：Nacos中服务存储和数据存储的最外层都是一个名为namespace的东西，用来做最外层隔离

   * 在Nacos控制台创建namespace，用来隔离不同环境

   * 在服务的配置文件中配置命名空间

     ![image-20230505205906511](https://whymechen.oss-cn-chengdu.aliyuncs.com/image/202305052059197.png)

   > namespace用来做环境隔离，每个namespace都有唯一id，**不同namespace下的服务不可见**

7. Nacos和Eureka对比

   * 共同点
     * 都支持服务注册和服务拉取
     * 都支持服务提供者心跳方式做健康检测
   * 不同点
     * Nacos支持服务端主动检测提供者状态：临时实例采用心跳模式，非临时实例采用主动检测模式
     * 临时实例心跳不正常会被剔除，非临时实例则不会被剔除
     * Nacos支持服务列表变更的消息推送模式，服务列表更新更及时
     * Nacos集群默认采用AP方式，当集群中存在非临时实例时，采用CP模式；Eureka采用AP方式

#### 配置管理

##### 统一配置管理

> * 在Nacos中添加配置文件
> * 在微服务中引入nacos的config依赖
> * 在微服务中添加bootstrap.yml，配置nacos地址、当前环境、服务名称、文件后缀名。这些决定了程序
>   启动时去nacos读取哪个文件

1. 在nacos中创建配置文件

   ![image-20230505222635283](https://whymechen.oss-cn-chengdu.aliyuncs.com/image/202305052226057.png)

2. 配置获取

   ![image-20230505225825641](https://whymechen.oss-cn-chengdu.aliyuncs.com/image/202305052258264.png)

   ~~~yaml
   spring:
     application:
       name: userservice # 服务名称
     profiles:
       active: dev # 开发环境
     cloud:
       nacos:
         config:
           file-extension: yaml # 文件后缀名
         server-addr: localhost:8848 # Nacos地址
   ~~~

##### 配置热更新

1. 方式一：

   ![image-20230506171558427](https://whymechen.oss-cn-chengdu.aliyuncs.com/image/202305061716283.png)

2. 方式二：

   ![image-20230506172743217](https://whymechen.oss-cn-chengdu.aliyuncs.com/image/202305061727103.png)

##### 配置共享

1. 创建多配置文件

   ![image-20230506173120433](https://whymechen.oss-cn-chengdu.aliyuncs.com/image/202305061745737.png)

2. 多配置文件优先级：[服务名]-[环境].yaml>[服务名].yaml>本地配置

##### 搭建Nacos集群

1. 步骤
   * 搭建MySQL集群并初始化数据库表
   * 下载解压nacos
   * 修改集群配置(节点信息)数据库配置
   * 分别启动多个nacos节点
   * nginx反向代理

### Feign

#### RestTemplate的问题

![image-20230506175657177](https://whymechen.oss-cn-chengdu.aliyuncs.com/image/202305061756412.png)

#### Feign

官网：https://github.com/OpenFeign/feign

1. feign：一个声明式的http客户端，实现优雅的http请求发送。

2. feign客户端的使用

   * 引入依赖

     ~~~xml
     <dependency>            <groupId>org.springframework.cloud</groupId>
      <artifactId>spring-cloud-starter-openfeign</artifactId>
       </dependency>
     ~~~

   * 启动类中添加注解开启Feign功能

     ![image-20230506180353483](https://whymechen.oss-cn-chengdu.aliyuncs.com/image/202305061803740.png)

   * 编写Feign客户端

     ![image-20230506180828135](https://whymechen.oss-cn-chengdu.aliyuncs.com/image/202305061808526.png)

3. 自定义feign配置

   ![image-20230506213938619](https://whymechen.oss-cn-chengdu.aliyuncs.com/image/202305062139929.png)

   日志自定义方式一：配置文件

   ![image-20230506222903876](https://whymechen.oss-cn-chengdu.aliyuncs.com/image/202305062229450.png)

   日志自定义方式二：java代码

   ![image-20230506223002338](https://whymechen.oss-cn-chengdu.aliyuncs.com/image/202305062230717.png)

4. Feign的性能优化

   ![image-20230506223822399](https://whymechen.oss-cn-chengdu.aliyuncs.com/image/202305062238506.png)

   * 连接池配置

     ![image-20230506224047084](https://whymechen.oss-cn-chengdu.aliyuncs.com/image/202305062240233.png)

5. 最佳实践

   * 方式一：

     ![image-20230506224848056](https://whymechen.oss-cn-chengdu.aliyuncs.com/image/202305062248178.png)

   * 方式二：

     ![image-20230506225107978](https://whymechen.oss-cn-chengdu.aliyuncs.com/image/202305062251195.png)

     > 实现步骤：
     >
     > * 创建一个module，命名为feign-api，引入feign相关依赖
     > * 将order-service中编写的UserClient、User、DefaultFeignConfiguration都复制到feign-api项目中
     > * 在order-service中引入feign-api的依赖
     > * 修改order-service中的所有与上述三个组件有关的import部分，改成导入feign-api中的包
     >
     > ![image-20230506231053347](https://whymechen.oss-cn-chengdu.aliyuncs.com/image/202305062310886.png)

### 统一网关Gateway

#### 简介

1. 网关功能
   * 身份认证和权限校验
   * 服务路由和负责均衡
   * 请求限流
2. SpringCloud的网关实现
   * gateway：基于Spring5中提供的WebFlux，属于响应式编程的实现，具备更好的性能。
   * zuul：基于Servlet的实现，属于阻塞式编程。

#### 搭建网关服务

1. 步骤：

   * 创建新的module，引入SpringCloudGateway的依赖和nacos的服务发现依赖

     ![image-20230506231549166](https://whymechen.oss-cn-chengdu.aliyuncs.com/image/202305062315923.png)

   * 编写路由配置及nacos地址

     > 网关路由可以配置的内容包括
     >
     > * 路由id:路由唯一标示
     > * uri: 路由目的地，支持lb和http两种
     > * predicates: 路由断言，判断请求是否符合要求，符合则转发到路由目的地址
     > * filters:路由过滤器，处理请求或响应

     ~~~xml
     server:
       port: 10086
     spring:
       application:
         name: gateway
       cloud:
         nacos:
           server-addr: localhost:8848
         gateway:
           routes: # 网关路由配置
             - id: user-service # 路由id，自定义，只要唯一即可
               uri: lb://userservice # 路由的目标地址，lb就是负载均衡，后面跟服务名称，还可以使用http://127.0.0.1:8081的方式配置
               predicates: # 路由断言，即判断路由是否符合规则
                 - Path=/user/** # 按照路由路径匹配，只要以/user/开头就匹配
             - id: order-service
               uri: lb://orderservice
               predicates:
                 - Path=/order/**
     ~~~

2. 网关流程

   ![image-20230507115109352](https://whymechen.oss-cn-chengdu.aliyuncs.com/image/202305071151354.png)

3. 路由断言工厂

   > 在配置文件中写的断言规则只是字符串，这些字符串会被Predicate Factory读取并处理，转变为路由判断的条件
   > 例如Path=/user/**是按照路径匹配，这个规则是由orq.springframework.cloud.qateway.handler.predicatePathRoutePredicateFactory类来处理的

   ![image-20230507115523705](https://whymechen.oss-cn-chengdu.aliyuncs.com/image/202305071155592.png)
   
4. 路由过滤器（GatewayFilter）：网关中提供的一种过滤器，可以对进入网关的**请求**和微服务返回的**响应**做处理。

   ![image-20230508225305428](https://whymechen.oss-cn-chengdu.aliyuncs.com/image/202305082253251.png)

   * 局部过滤器：配置在路由下

   ~~~xml
         routes:
           - id: user-service # 路由标示，必须唯一
             uri: lb://userservice # 路由的目标地址
             predicates: # 路由断言，判断请求是否符合规则
               - Path=/user/** # 路径断言，判断路径是否是以/user开头，如果是则符合
             filter:
               - AddRequestHeader=Trueth,Come on whyme-chen!
   ~~~

   * 默认过滤器

   ![image-20230508225828849](https://whymechen.oss-cn-chengdu.aliyuncs.com/image/202305082258640.png)

5. 全局过滤器（GlobalFilter）

   全局过滤器的作用也是处理一切进入网关的请求和微服务响应，与GatewayFilter的作用一样。区别在于GatewayFilter通过配置定义，处理逻辑是固定的。而GlobalFilter的逻辑需要自己写代码实现。

   ![image-20230508230421859](https://whymechen.oss-cn-chengdu.aliyuncs.com/image/202305082304761.png)

6. 过滤器执行顺序

   ![image-20230508231853814](https://whymechen.oss-cn-chengdu.aliyuncs.com/image/202305082318558.png)

   > * 每一个过滤器都必须指定一个int类型的order值，order值越小，优先级越高，执行顺序越靠前.
   > * GlobalFilter通过实现Ordered接口，或者添加@Order注解来指定order值，由我们自己指定路由过滤器和defaultFilter的order由Spring指定，默认是按照声明顺序从1递增。
   > * 当过滤器的order值一样时，会按照 defaultFilter > 路由过滤器>GlobalFilter的顺序执行。

7. 跨域问题处理

   ![image-20230508232228486](https://whymechen.oss-cn-chengdu.aliyuncs.com/image/202305082322188.png)

   ![image-20230508232245310](https://whymechen.oss-cn-chengdu.aliyuncs.com/image/202305082322067.png)

### 服务器容错Sentinel

### 分布式事务Seata

## RabbitMQ

### MQ基本概念

1. MQ：全称Message Queue (消息队列)，是在消息的传输过程中保存消息的容器。多用于分布式系统之间进行通信。

2. 优势

   * 应用解耦

   * 削峰填谷

   * 异步提速

     ![image-20230313225333941](https://whymechen.oss-cn-chengdu.aliyuncs.com/image/202303132253511.png)

3. 劣势

   * 系统可用性降低
   * 系统复杂性提高
   * 一致性问题

4. MQ应用条件

   * 生产者不需要从消费者处获得反馈
   * 容许短暂的不一致性

5. 常见的MQ产品

   * RabbitMQ
   * RocketMQ
   *  ActiveMQ
   * Kafka
   *  ZeroMQ
   * MetaMq

   ![image-20230313230133285](https://whymechen.oss-cn-chengdu.aliyuncs.com/image/202303132301585.png)

6. AMQP：AMQP，即Advanced Message Queuing Protocol (高级消息队列协议) ,是一个网络协议，是应用层协议的一个开放标准，为面向消息的中间件设计。基于此协议的客户端与消息中间件可传递消息，并不受客户端/中间件不同产品，不同的开发语言等条件的限制。2006年， AMQP规范发布。类比HTTP。

### RabbitMQ简介

![image-20230313232906539](https://whymechen.oss-cn-chengdu.aliyuncs.com/image/202303132329639.png)

![image-20230313232947012](https://whymechen.oss-cn-chengdu.aliyuncs.com/image/202303132329894.png)

![image-20230313233040344](https://whymechen.oss-cn-chengdu.aliyuncs.com/image/202303132330009.png)

![image-20230313233121119](https://whymechen.oss-cn-chengdu.aliyuncs.com/image/202303132331854.png)

### 快速使用

官网：https://www.rabbitmq.com/

1. 下载安装和管控台的使用

   > 使用docker安装rabbitmq：https://blog.csdn.net/weixin_44666439/article/details/127265712?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-0-127265712-blog-124470698.235^v27^pc_relevant_3mothn_strategy_recovery&spm=1001.2101.3001.4242.1&utm_relevant_index=3

2. 使用**简单模式**完成消息传递

   * 创建工程（生产者、消费者）
   * 分别添加依赖
   
   ~~~xml
    <dependency>
         <groupId>com.rabbitmq</groupId>
         <artifactId>amqp-client</artifactId>
         <version>5.16.0</version>
       </dependency>
   ~~~
   
   * 编写生产者发送消息、编写消费者接收消息
   
   ~~~java
   package org.example.producer;
   
   import com.rabbitmq.client.AMQP;
   import com.rabbitmq.client.Channel;
   import com.rabbitmq.client.Connection;
   import com.rabbitmq.client.ConnectionFactory;
   
   import java.io.IOException;
   import java.nio.charset.StandardCharsets;
   import java.util.concurrent.TimeoutException;
   
   /**
    * 简单模式
    * @Author chen
    * @Date 2023/3/25
    * @Version 1.0
    **/
   public class Producer_HelloWorld {
       public static void main(String[] args) throws IOException, TimeoutException {
           //创建连接工厂
           ConnectionFactory connectionFactory = new ConnectionFactory();
           //设置参数
           connectionFactory.setHost("47.120.2.57");
           connectionFactory.setPort(5672);
           connectionFactory.setVirtualHost("demo");
           connectionFactory.setUsername("admin");
           connectionFactory.setPassword("admin");
           //创建连接
           Connection connection = connectionFactory.newConnection();
           //创建Channel
           Channel channel = connection.createChannel();
           //创建队列Quene
           /*
            * queueDeclare方法参数说明
            * String queue,队列名称
         * boolean durable,是否持久化
            * boolean exclusive,是否独占，只能有一个消费者监听该队列。当Connection关闭时，是否删除队列
            * boolean autoDelete,是否自动删除，当该队列没有消费者时，自动删除
            * Map<String, Object> arguments,参数
            */
           AMQP.Queue.DeclareOk declareOk = channel.queueDeclare("hello",true,false,false,null);
           //发送消息
           String body = "hello rabbitmq!";
           /*
            *basicPublish方法参数说明
            * String exchange,交换机名称，简单模式下交换机默认使用“
            * String routingKey,路由名称
            * BasicProperties props,配置信息
            * byte[] body,发送消息数据
            */
           channel.basicPublish("","hello",null,body.getBytes(StandardCharsets.UTF_8));
   
           channel.close();
           connection.close();
       }
   }
   ~~~
   
   ~~~java
   package org.example.consumer;
   
   import com.rabbitmq.client.*;
   
   import java.io.IOException;
   import java.nio.charset.StandardCharsets;
   import java.util.concurrent.TimeoutException;
   
   /**
    * 消费者
    * @Author chen
    * @Date 2023/3/25
    * @Version 1.0
    **/
   public class ConsumerDemo1 {
       public static void main(String[] args) throws IOException, TimeoutException {
           //创建连接工厂
           ConnectionFactory connectionFactory = new ConnectionFactory();
           //设置参数
           connectionFactory.setHost("47.120.2.57");
           connectionFactory.setPort(5672);
           connectionFactory.setVirtualHost("demo");
           connectionFactory.setUsername("admin");
           connectionFactory.setPassword("admin");
           //创建连接
           Connection connection = connectionFactory.newConnection();
           //创建Channel
           Channel channel = connection.createChannel();
           //创建队列Quene
           AMQP.Queue.DeclareOk declareOk = channel.queueDeclare("hello",true,false,false,null);
           //消费消息
           Consumer consumer = new DefaultConsumer(channel){
               /**
                * 这是一个回调方法，当收到消息后会自动执行该方法
                * @param consumerTag 标识
                * @param envelope 获取信息，包括：交换机、路由key
                * @param properties 配置信息
                * @param body 数据
                * @throws IOException
                */
               @Override
               public void handleDelivery(String consumerTag,
                                          Envelope envelope,
                                          AMQP.BasicProperties properties,
                                          byte[] body) throws IOException {
                   System.out.println("consumerTag:"+consumerTag);
                   System.out.println("envelope:"+envelope.getExchange());
                   System.out.println("envelope:"+envelope.getRoutingKey());
                   System.out.println("properties:"+properties);
                   System.out.println("body:"+new String(body));
               }
           };
           channel.basicConsume("hello",true,consumer);
   
       }
   }
   
   ~~~
   
3. 工作队列模式（Work Queues）

   * 特点：与简单模式相比有多个消费者
   * 应用场景：对于任务过重或任务较多情况使用工作队列可以提高任务处理的速度
   * 在一个队列中如果有多个消费者，那么消费者之间对于同一个消息的关系是竞争的关系
   * Work Queues 对于任务过重或任务较多情况使用工作队列可以提高任务处理的速度。例如: 短信服务部署多个只需要有一个节点成功发送即可。

4. Pub/Sub订阅模式

   ![image-20230510215142430](https://whymechen.oss-cn-chengdu.aliyuncs.com/image/202305102151306.png)

5. 路由模式

   ![image-20230511115213003](https://whymechen.oss-cn-chengdu.aliyuncs.com/image/202305111152263.png)

### Spring整合RabbitMQ

# 持续集成

## Docker

学习视频：https://www.bilibili.com/video/BV1CJ411T7BK?p=1

### 简介

1. 容器：

   * **解决软件跨环境迁移问题**
   * 完全使用沙箱机制，相互隔离
   * 性能开销极低

2. Docker：一个开源的应用容器引擎

   * 官网：https://www.docker.com
   * 诞生于2013年初,基于Go语言实现，dotCloud 公司出品(后改名为Docker Inc)
   * Docker可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的Linux机器上。
   * Docker从17.03版本之后分为CE (Community Edition:社区版)和EE (Enterprise Edition:企业版)

3. docker架构

   ![image-20230311195708638](https://whymechen.oss-cn-chengdu.aliyuncs.com/image/202303111957973.png)

4. 配置镜像加速器

   阿里云：https://cr.console.aliyun.com/cn-heyuan/instances/mirrors

5. docker容器虚拟化和传统虚拟机虚拟化的比较

   ![image-20230311230728514](https://whymechen.oss-cn-chengdu.aliyuncs.com/image/202303112307226.png)

### 常用命令

1. 服务相关

   > 启动docker服务：system start docker
   >
   > 停止docker服务：system stop docker
   >
   > 重启docker服务：system restart docker
   >
   > 查看docker服务状态：system status docker
   >
   > 开机启动docker服务：system enable docker

2. 镜像相关命令

   镜像地址：https://hub.docker.com/

   > 查看镜像：docker images
   >
   > 搜索镜像：docker search
   >
   > 拉取镜像：docker pull
   >
   > 删除镜像：docker rmi

3. 容器相关命令

   > 查看正在运行的容器：docker ps
   >
   > ​	-a：表示查看所有容器
   >
   > 创建容器：docker run 
   >
   > ​	-i：保持容器运行。通常与-t同时使用。加入it这两个参数后,容器创建后自动进入容器中，退出容器后，容器自动关闭。
   >
   > ​	-t: 为容器重新分配一个伪输入终端，通常与-i同时使用。
   > ​	-d:以守护(后台)模式运行容器。创建一个容器在后台运行， 需要使用dockerexec进入容器。退出后，容器不会关闭。
   > ​	-it创建的容器-般称为交互式容器， -id 创建的容器一般称为守护式容器
   > ​	--name:为创建的容器命名。
   >
   > 进入容器：docker exec
   > 启动容器：docker start
   > 停止容器：docker stop
   > 删除容器：docker rm
   > 查看容器信息：docker inspect

### 容器数据卷

1. 数据卷：数据卷是宿主机中的一个目录或文件

   * 当容器目录和数据卷目录绑定后，对方的修改会立即同步
   * 一个数据卷可以被多个容器同时挂载
   * -个容器也可以被挂载多个数据卷

2. 作用

   * 容器数据持久化
   * 外部机器和容器间接通信
   * 容器之间数据交换

3. 配置数据卷

   > docker run ... -v 宿主机目录(文件) :容器内目录(文件)
   >
   > 注意事项：
   >
   > * 目录必须是绝对路径
   > * 如果目录不存在,会自动创建
   > * 可以挂载多个数据卷

4. 数据卷容器

   ![image-20230311213730377](https://whymechen.oss-cn-chengdu.aliyuncs.com/image/202303112137385.png)

### 应用部署

### Dockerfile

1. docker镜像原理

   ![image-20230311215746393](https://whymechen.oss-cn-chengdu.aliyuncs.com/image/202303112157213.png)

2. docker镜像制作（基于容器制作）

   ![image-20230311220359398](https://whymechen.oss-cn-chengdu.aliyuncs.com/image/202303112204252.png)

#### Dockerfile

1. 简介

   * Dockerfile是一个文本文件
   * 包含了-条条的指令，每一条指令构建-层,基于基础镜像，最终构建出一一个新的镜像
   * 对于开发人员:可以为开发团队提供一个完全一致的开发环境
   * 对于测试人员:可以直接拿开发时所构建的镜像或者通过Dockerfile文件构建一个新的镜像开始工作
   * 对于运维人员:在部署时，可以实现应用的无缝移植

2. 常见关键字

   | 关键字      | 作用                     | 备注                                                         |
   | ----------- | ------------------------ | ------------------------------------------------------------ |
   | FROM        | 指定父镜像               | 指定dockerfile基于那个image构建                              |
   | MAINTAINER  | 作者信息                 | 用来标明这个dockerfile谁写的                                 |
   | LABEL       | 标签                     | 用来标明dockerfile的标签 可以使用Label代替Maintainer 最终都是在docker image基本信息中可以查看 |
   | RUN         | 执行命令                 | 执行一段命令 默认是/bin/sh 格式: RUN command 或者 RUN ["command" , "param1","param2"] |
   | CMD         | 容器启动命令             | 提供启动容器时候的默认命令 和ENTRYPOINT配合使用.格式 CMD command param1 param2 或者 CMD ["command" , "param1","param2"] |
   | ENTRYPOINT  | 入口                     | 一般在制作一些执行就关闭的容器中会使用                       |
   | COPY        | 复制文件                 | build的时候复制文件到image中                                 |
   | ADD         | 添加文件                 | build的时候添加文件到image中 不仅仅局限于当前build上下文 可以来源于远程服务 |
   | ENV         | 环境变量                 | 指定build时候的环境变量 可以在启动的容器的时候 通过-e覆盖 格式ENV name=value |
   | ARG         | 构建参数                 | 构建参数 只在构建的时候使用的参数 如果有ENV 那么ENV的相同名字的值始终覆盖arg的参数 |
   | VOLUME      | 定义外部可以挂载的数据卷 | 指定build的image那些目录可以启动的时候挂载到文件系统中 启动容器的时候使用 -v 绑定 格式 VOLUME ["目录"] |
   | EXPOSE      | 暴露端口                 | 定义容器运行的时候监听的端口 启动容器的使用-p来绑定暴露端口 格式: EXPOSE 8080 或者 EXPOSE 8080/udp |
   | WORKDIR     | 工作目录                 | 指定容器内部的工作目录 如果没有创建则自动创建 如果指定/ 使用的是绝对地址 如果不是/开头那么是在上一条workdir的路径的相对路径 |
   | USER        | 指定执行用户             | 指定build或者启动的时候 用户 在RUN CMD ENTRYPONT执行的时候的用户 |
   | HEALTHCHECK | 健康检查                 | 指定监测当前容器的健康监测的命令 基本上没用 因为很多时候 应用本身有健康监测机制 |
   | ONBUILD     | 触发器                   | 当存在ONBUILD关键字的镜像作为基础镜像的时候 当执行FROM完成之后 会执行 ONBUILD的命令 但是不影响当前镜像 用处也不怎么大 |
   | STOPSIGNAL  | 发送信号量到宿主机       | 该STOPSIGNAL指令设置将发送到容器的系统调用信号以退出。       |
   | SHELL       | 指定执行脚本的shell      | 指定RUN CMD ENTRYPOINT 执行命令的时候 使用的shell            |

### Docker Compose

![image-20230311230230122](https://whymechen.oss-cn-chengdu.aliyuncs.com/image/202303112302382.png)

### Docker 私有仓库

## Rancher

## kubernetes

# 分布式搜索

# 分布式缓存

# 分布式日志

# 分布式事务

# RPC

参考：https://www.bilibili.com/video/BV11i4y1N7LQ/?spm_id_from=333.337.search-card.all.click&vd_source=fabefd3fabfadb9324761989b55c26ea

# apisix

官网：https://apisix.apache.org/zh/

参考：

* [【云原生网关】apisix使用详解](http://www.rply.cn/news/71253.html)